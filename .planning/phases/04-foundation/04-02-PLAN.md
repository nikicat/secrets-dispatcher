---
phase: 04-foundation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/daemon/daemon.go
  - internal/daemon/dispatcher.go
  - internal/daemon/notify.go
  - internal/daemon/daemon_test.go
  - main.go
autonomous: true
requirements:
  - DBUS-01
  - INFRA-01
  - INFRA-02
  - TEST-04

must_haves:
  truths:
    - "The daemon registers net.mowaka.SecretsDispatcher1 on a D-Bus bus and responds to Ping/GetVersion stub methods"
    - "A client can call Ping() via D-Bus and receive 'pong' back"
    - "The daemon sends READY=1 via sd-notify after successful bus registration"
    - "The daemon logs to stderr with structured slog (journald picks this up automatically)"
    - "The daemon subcommand does NOT start any HTTP/WebSocket listeners"
    - "Integration tests with a private dbus-daemon verify name registration and stub method calls without root"
  artifacts:
    - path: "internal/daemon/daemon.go"
      provides: "Daemon run loop with D-Bus registration, signal handling, context cancellation"
      exports: ["Daemon", "Config"]
    - path: "internal/daemon/dispatcher.go"
      provides: "D-Bus interface stub with Ping and GetVersion methods"
      exports: ["Dispatcher", "BusName", "ObjectPath", "Interface"]
    - path: "internal/daemon/notify.go"
      provides: "sd-notify implementation writing READY=1 to NOTIFY_SOCKET"
      exports: ["SdNotify"]
    - path: "internal/daemon/daemon_test.go"
      provides: "Integration tests with private dbus-daemon"
      min_lines: 60
    - path: "main.go"
      provides: "daemon subcommand routing"
      contains: "case \"daemon\""
  key_links:
    - from: "main.go"
      to: "internal/daemon/daemon.go"
      via: "switch case creating daemon.Config and calling daemon.Run()"
      pattern: "daemon\\.Run|daemon\\.New"
    - from: "internal/daemon/daemon.go"
      to: "internal/daemon/dispatcher.go"
      via: "conn.Export(dispatcher, ObjectPath, Interface)"
      pattern: "conn\\.Export.*Dispatcher"
    - from: "internal/daemon/daemon.go"
      to: "internal/daemon/notify.go"
      via: "SdNotify(\"READY=1\") after bus name acquired"
      pattern: "SdNotify.*READY"
    - from: "internal/daemon/daemon_test.go"
      to: "internal/daemon/daemon.go"
      via: "starts daemon against private dbus-daemon, calls stub methods"
      pattern: "startDBusDaemonWithPolicy|dbus\\.Connect"
---

<objective>
Create the `secrets-dispatcher daemon` subcommand that registers a stub D-Bus service on the system bus, proving the D-Bus policy and wire protocol work end-to-end. The daemon skeleton provides: bus name registration, stub Ping/GetVersion methods, sd-notify READY=1, structured slog logging, and graceful signal handling.

Purpose: This is the foundation for all Phase 5+ companion daemon logic. By proving D-Bus registration and policy enforcement work with stubs, Phase 5 can focus on real business logic without worrying about D-Bus plumbing.

Output: `internal/daemon/` package with daemon run loop, D-Bus dispatcher stubs, sd-notify, integration tests with private dbus-daemon, and "daemon" subcommand in main.go.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation/04-CONTEXT.md
@.planning/phases/04-foundation/04-RESEARCH.md
@.planning/phases/04-foundation/04-01-SUMMARY.md

<interfaces>
<!-- Key patterns and contracts from the codebase and Plan 01. -->

From proxy_test.go (existing private dbus-daemon test helper — extend this pattern):
```go
func startDBusDaemon(t *testing.T, socketPath string) (*exec.Cmd, string) {
    t.Helper()
    addr := "unix:path=" + socketPath
    cmd := exec.Command("dbus-daemon", "--session", "--nofork", "--address="+addr)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Start(); err != nil {
        t.Fatalf("start dbus-daemon: %v", err)
    }
    for i := 0; i < 50; i++ {
        if _, err := os.Stat(socketPath); err == nil {
            return cmd, addr
        }
        time.Sleep(100 * time.Millisecond)
    }
    // ...
}
```

From internal/dbus/types.go (existing D-Bus constants — daemon uses a DIFFERENT bus name):
```go
const (
    ServiceInterface    = "org.freedesktop.Secret.Service"  // existing proxy
    BusName             = "org.freedesktop.secrets"          // existing proxy
)
// Daemon uses: net.mowaka.SecretsDispatcher1 (NOT org.freedesktop.secrets)
```

From internal/testutil/mockservice.go (existing D-Bus export pattern):
```go
// godbus Export pattern — dispatcher stubs follow same approach
conn.Export(handler, objectPath, interfaceName)
conn.Export(dbus.DefaultIntrospectHandler(handler, objectPath), objectPath,
    "org.freedesktop.DBus.Introspectable")
```

From main.go (Plan 01 already added "provision" case — add "daemon" case after it):
```go
switch os.Args[1] {
case "serve":
    runServe(os.Args[2:])
// ... existing cases ...
case "provision":      // added by Plan 01
    runProvision(os.Args[2:])
// ADD: case "daemon":
//     runDaemon(os.Args[2:])
}
```

From main.go runServe() (slog setup pattern to follow — daemon uses same approach):
```go
// When running under systemd (INVOCATION_ID set), use JSON handler
// Otherwise use tint colored handler for terminal output
if os.Getenv("INVOCATION_ID") != "" {
    slog.SetDefault(slog.New(slog.NewJSONHandler(os.Stderr, nil)))
} else {
    slog.SetDefault(slog.New(tint.NewHandler(os.Stderr, &tint.Options{Level: logLevel})))
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create internal/daemon package with daemon skeleton, dispatcher stubs, and sd-notify</name>
  <files>
    internal/daemon/daemon.go
    internal/daemon/dispatcher.go
    internal/daemon/notify.go
    main.go
  </files>
  <action>
Create the `internal/daemon/` package with three files:

**dispatcher.go** — D-Bus interface stubs:
- Constants:
  ```go
  const (
      BusName    = "net.mowaka.SecretsDispatcher1"
      ObjectPath = dbus.ObjectPath("/net/mowaka/SecretsDispatcher1")
      Interface  = "net.mowaka.SecretsDispatcher1"
  )
  ```
- `Dispatcher` struct with `version string` field
- `NewDispatcher(version string) *Dispatcher`
- Stub methods (return canned responses, Phase 5 replaces with real logic):
  - `Ping() (string, *dbus.Error)` — returns "pong", nil
  - `GetVersion() (string, *dbus.Error)` — returns d.version, nil
- These method signatures match the godbus export convention (return value + *dbus.Error)

**notify.go** — sd-notify implementation (15 lines, no new dependency):
- `SdNotify(state string)` — reads `NOTIFY_SOCKET` from env, writes state string to Unix datagram socket. Silently returns if NOTIFY_SOCKET is not set (non-systemd environment). Logs warning on dial failure but does not return error (fire-and-forget). Import: "net", "os", "log/slog".

**daemon.go** — Main daemon run loop:
- `Config` struct:
  - `BusAddress string` — D-Bus address to connect to. Empty = system bus (production). Non-empty = custom address (tests).
  - `Version string` — version to report via GetVersion
- `Run(ctx context.Context, cfg Config) error`:
  1. Connect to D-Bus: if cfg.BusAddress is empty, use `dbus.ConnectSystemBus()`; otherwise use `dbus.Connect(cfg.BusAddress)` — this is the key testing seam
  2. Create Dispatcher: `NewDispatcher(cfg.Version)`
  3. Export dispatcher on connection: `conn.Export(dispatcher, ObjectPath, Interface)`
  4. Export introspectable: `conn.Export(dbus.DefaultIntrospectHandler(dispatcher, ObjectPath), ObjectPath, "org.freedesktop.DBus.Introspectable")` — REQUIRED, see anti-patterns in RESEARCH.md
  5. Request bus name: `conn.RequestName(BusName, dbus.NameFlagDoNotQueue)` — check reply is `dbus.RequestNameReplyPrimaryOwner`
  6. Log success: `slog.Info("daemon ready", "bus_name", BusName)`
  7. Send sd-notify: `SdNotify("READY=1")`
  8. Block on `<-ctx.Done()` (context cancelled by signal handler in main.go)
  9. Cleanup: `conn.Close()`
  10. Return nil on clean shutdown

IMPORTANT: The daemon does NOT start any HTTP/WebSocket/Web UI listeners (INFRA-02). It only registers on D-Bus and blocks.

**main.go changes:**
1. Add `case "daemon":` to the switch, calling `runDaemon(os.Args[2:])`
2. Add `runDaemon(args []string)` function:
   - Parse flags: `--bus-address` (string, optional D-Bus address for testing), `--log-level` (string, default "info")
   - Set up slog: detect `INVOCATION_ID` env var (set by systemd) — if present, use `slog.NewJSONHandler(os.Stderr)` (INFRA-01); otherwise use tint handler. Same pattern as existing runServe().
   - Create context with signal handling: `signal.NotifyContext(ctx, syscall.SIGTERM, syscall.SIGINT)`
   - Call `daemon.Run(ctx, cfg)`
   - If error, log and exit 1
3. Add "daemon" to printUsage() help text:
   ```
   daemon        Run companion daemon (registers on system D-Bus)
   ```
4. Add import for `"github.com/nikicat/secrets-dispatcher/internal/daemon"`
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/daemon/ && go build .</automated>
  </verify>
  <done>
    - internal/daemon/ package compiles with daemon.go, dispatcher.go, notify.go
    - Daemon.Run() connects to D-Bus, exports stubs, requests name, sends READY=1, blocks until context done
    - Dispatcher has Ping() and GetVersion() stubs returning canned responses
    - SdNotify writes to NOTIFY_SOCKET when set, silently succeeds otherwise
    - main.go has "daemon" case wired
    - `go build .` succeeds
    - No HTTP/WebSocket listeners started by daemon subcommand
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests with private dbus-daemon</name>
  <files>
    internal/daemon/daemon_test.go
  </files>
  <action>
Create integration tests that prove the daemon can register on a D-Bus bus and serve stub methods. Uses a private `dbus-daemon` process with a policy config file — same approach as the existing `startDBusDaemon()` in `proxy_test.go` but extended with a policy config.

**daemon_test.go:**

Helper function `startDBusDaemonWithPolicy(t *testing.T)`:
- Creates a temp dir with `t.TempDir()`
- Writes a policy config file that mirrors the system bus policy structure (see RESEARCH.md Pattern 2). The policy must include:
  - `<type>session</type>` (we're running as a regular user, not the real system bus)
  - Default deny on `own` and `send_type="method_call"`
  - Allow all `receive_type` (method_return, error, signal)
  - Allow `send_destination="org.freedesktop.DBus"` (for RequestName)
  - Allow current user (`user="{current_uid}"`) to own `net.mowaka.SecretsDispatcher1` and send to it
  - IMPORTANT: Use numeric UID string (e.g., `user="1000"`) via `os.Getuid()` since the private dbus-daemon resolves the current user. Using the username also works.
- Starts `dbus-daemon --config-file={conf} --nofork`
- Waits for socket file to appear (poll loop, 50 iterations, 100ms each)
- Uses `t.Cleanup` to kill and wait on the process
- Returns the `unix:path=...` address string

Test cases:

1. `TestDaemon_RegistersAndServesStubs` — THE main integration test:
   - Start private dbus-daemon with policy
   - Start daemon.Run() in a goroutine with a cancellable context, passing the private bus address
   - Wait briefly for daemon to register (poll or short sleep)
   - Create a SECOND D-Bus connection (the "client") to the same private bus
   - Call `Ping()` on `net.mowaka.SecretsDispatcher1` via `client.Object(BusName, ObjectPath).Call(Interface+".Ping", 0)` — verify returns "pong"
   - Call `GetVersion()` — verify returns the configured version string
   - Cancel the context to shut down the daemon
   - Verify daemon.Run() returns nil (clean shutdown)

2. `TestDaemon_NameAlreadyTaken` — Error case:
   - Start private dbus-daemon with policy
   - Create a connection and request the bus name first (simulate another instance)
   - Try to start daemon.Run() — verify it returns an error about not being primary owner

3. `TestDaemon_Introspectable` — Verify introspection works:
   - Start daemon on private bus
   - Call `org.freedesktop.DBus.Introspectable.Introspect` on the daemon's object path
   - Verify the XML output mentions `Ping` and `GetVersion` methods

4. `TestSdNotify_NoSocket` — Unit test for notify.go:
   - Unset NOTIFY_SOCKET env var
   - Call SdNotify("READY=1") — verify no error, no panic (silent no-op)

5. `TestSdNotify_WithSocket` — Unit test for notify.go:
   - Create a Unix datagram listener on a temp path
   - Set NOTIFY_SOCKET to that path
   - Call SdNotify("READY=1")
   - Read from the listener, verify received "READY=1"
   - Clean up with t.Cleanup

NOTE on policy denial test: Testing that a WRONG UID gets rejected requires two UIDs running in the same test. This is NOT possible without root. Policy denial testing is deferred to Phase 8 VM E2E. The tests here verify the POSITIVE path (correct UID can register and call methods).

Use `unix:path=` filesystem sockets (NOT `unix:abstract=`) to avoid cross-test collisions in parallel runs (anti-pattern from RESEARCH.md).
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 -v ./internal/daemon/...</automated>
  </verify>
  <done>
    - Integration tests start a private dbus-daemon with policy config
    - TestDaemon_RegistersAndServesStubs proves name registration + Ping + GetVersion work end-to-end
    - TestDaemon_NameAlreadyTaken verifies error handling when name is taken
    - TestDaemon_Introspectable verifies D-Bus introspection returns method info
    - TestSdNotify_NoSocket and TestSdNotify_WithSocket verify sd-notify behavior
    - All tests run without root (TEST-04)
    - `go test -race ./internal/daemon/...` passes
  </done>
</task>

</tasks>

<verification>
```bash
# All daemon tests pass
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 -v ./internal/daemon/...

# Full project still compiles
cd /home/nb/src/secrets-dispatcher && go build .

# Existing tests still pass (no regression)
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./...
```
</verification>

<success_criteria>
- `internal/daemon/` package exists with daemon.go, dispatcher.go, notify.go, daemon_test.go
- Daemon registers `net.mowaka.SecretsDispatcher1` on D-Bus and serves Ping/GetVersion stubs
- sd-notify sends READY=1 after registration
- Daemon does NOT start any HTTP/WebSocket listeners
- Logging goes to stderr via slog (INFRA-01)
- Integration tests run with private dbus-daemon, no root required (TEST-04)
- `secrets-dispatcher daemon` subcommand works
- `go test -race ./internal/daemon/...` passes
- `go test -race ./...` passes (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-02-SUMMARY.md`
</output>

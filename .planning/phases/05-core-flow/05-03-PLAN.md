---
phase: 05-core-flow
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - internal/daemon/daemon.go
  - internal/daemon/dispatcher.go
  - internal/daemon/handler.go
  - internal/daemon/activation.go
autonomous: true
requirements: [DBUS-03, DBUS-04, DBUS-05, DBUS-06, DBUS-07, GPG-03]

must_haves:
  truths:
    - "D-Bus RequestSecret method blocks until user approves/denies on VT, then returns secret or error"
    - "D-Bus RequestSign method blocks until user approves/denies on VT, then returns GPG signature or error"
    - "Denied requests return net.mowaka.Error.Denied with reason text"
    - "Timed-out requests return net.mowaka.Error.Timeout mentioning VT number"
    - "D-Bus activation file enables auto-start of daemon on method call"
    - "Multiple concurrent D-Bus callers block independently"
    - "GPG signing reuses existing internal/gpgsign GPGRunner interface"
  artifacts:
    - path: "internal/daemon/handler.go"
      provides: "RequestSecret and RequestSign D-Bus method implementations"
      exports: ["Dispatcher.RequestSecret", "Dispatcher.RequestSign"]
    - path: "internal/daemon/daemon.go"
      provides: "Updated Run() that starts TUI, approval manager, and wires to D-Bus"
      contains: "tea.NewProgram"
    - path: "internal/daemon/activation.go"
      provides: "D-Bus service activation file content and install helper"
      exports: ["ActivationFileContent"]
  key_links:
    - from: "internal/daemon/handler.go"
      to: "internal/approval"
      via: "Manager.RequireApproval / CreateGPGSignRequest"
      pattern: "approval\\.Manager"
    - from: "internal/daemon/handler.go"
      to: "internal/tui"
      via: "p.Send(NewRequestMsg)"
      pattern: "program\\.Send"
    - from: "internal/daemon/daemon.go"
      to: "internal/tui"
      via: "tea.NewProgram with WithInput/WithOutput on VT fd"
      pattern: "tea\\.NewProgram"
---

<objective>
Wire the D-Bus dispatcher to the approval manager and TUI: implement RequestSecret and RequestSign methods that block until user approval, start the bubbletea TUI on the VT, and create the D-Bus activation file for auto-start.

Purpose: This is the core wiring plan that connects the D-Bus caller to the VT approval interface. After this plan, a D-Bus method call triggers a visible request on VT8 that can be approved or denied via keyboard.

Output: Updated `internal/daemon/` with real D-Bus handlers, TUI startup, and activation file.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-core-flow/05-CONTEXT.md
@.planning/phases/05-core-flow/05-RESEARCH.md
@.planning/phases/04-foundation/04-02-SUMMARY.md
@.planning/phases/05-core-flow/05-01-SUMMARY.md
@.planning/phases/05-core-flow/05-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts from existing code and Plan 01/02 outputs. -->

From internal/daemon/dispatcher.go (Phase 4):
```go
const (
    BusName    = "net.mowaka.SecretsDispatcher1"
    ObjectPath = dbus.ObjectPath("/net/mowaka/SecretsDispatcher1")
    Interface  = "net.mowaka.SecretsDispatcher1"
)

type Dispatcher struct {
    version string
}

func NewDispatcher(version string) *Dispatcher
func (d *Dispatcher) Ping() (string, *dbus.Error)
func (d *Dispatcher) GetVersion() (string, *dbus.Error)
```

From internal/daemon/daemon.go (Phase 4):
```go
type Config struct {
    BusAddress string
    Version    string
}
func Run(ctx context.Context, cfg Config) error
```

From internal/approval/manager.go:
```go
func (m *Manager) RequireApproval(ctx context.Context, client string, items []ItemInfo,
    session string, reqType RequestType, searchAttrs map[string]string, senderInfo SenderInfo) error
func (m *Manager) CreateGPGSignRequest(client string, info *GPGSignInfo, senderInfo SenderInfo) (string, error)
func (m *Manager) Approve(id string) error
func (m *Manager) Deny(id string) error
func (m *Manager) Subscribe(o Observer)
```

From internal/tui/model.go (Plan 02):
```go
type Config struct {
    LockMode      LockMode
    VTPath        string
    VTFD          uintptr
    CompanionUser string
    StartTime     time.Time
}
func NewModel(cfg Config, approveFn, denyFn func(string) error) Model
```

From internal/tui/messages.go (Plan 02):
```go
type NewRequestMsg struct {
    Request   *approval.Request
    ProcChain []procchain.ProcInfo
}
type RequestResolvedMsg struct {
    ID         string
    Resolution approval.Resolution
}
```

From internal/procchain/procchain.go (Plan 01):
```go
func Walk(startPID uint32, maxDepth int) []ProcInfo
```

From internal/tui/vt.go (Plan 01):
```go
func OpenVT(path string) (*os.File, error)
func LockVT(fd uintptr) error
func UnlockVT(fd uintptr) error
func CleanupOnSignal(fd uintptr) func()
type LockMode int
```

From internal/gpgsign/run.go:
```go
// GPGRunner interface already exists in internal/api/handlers.go
// The daemon can reuse the gpgsign package's Run function or the GPGRunner interface
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement D-Bus handler methods and activation file</name>
  <files>
    internal/daemon/dispatcher.go
    internal/daemon/handler.go
    internal/daemon/activation.go
  </files>
  <action>
**1. Update `internal/daemon/dispatcher.go`:**

Expand Dispatcher to hold references needed by handler methods:

```go
type Dispatcher struct {
    version    string
    mgr        *approval.Manager
    program    *tea.Program  // nil until TUI starts; methods wait or error
    resolver   senderResolver
}
```

Define `senderResolver` interface (for testability):
```go
// senderResolver abstracts D-Bus sender info resolution.
type senderResolver interface {
    Resolve(sender string) approval.SenderInfo
}
```

Update `NewDispatcher` to accept the new deps:
```go
func NewDispatcher(version string, mgr *approval.Manager, resolver senderResolver) *Dispatcher
```

Add `SetProgram(p *tea.Program)` method — called after TUI starts, before accepting D-Bus calls. The D-Bus methods check if program is nil and return an error if TUI is not yet initialized.

Keep existing `Ping()` and `GetVersion()` methods unchanged.

**2. Create `internal/daemon/handler.go`:**

Implement the two core D-Bus methods on Dispatcher:

**`RequestSecret(sender dbus.Sender, path string) (string, *dbus.Error)`**

Per RESEARCH.md Pattern 4 and CONTEXT.md caller-side experience:

1. If d.program is nil, return `net.mowaka.Error.NotReady` with "Daemon TUI not initialized"
2. Resolve sender info: `senderInfo := d.resolver.Resolve(string(sender))`
3. Walk process chain: `chain := procchain.Walk(senderInfo.PID, 5)`
4. Create approval request using `d.mgr.RequireApproval(ctx, ...)` in a blocking call
   - IMPORTANT: godbus v5 dispatches each method call in its own goroutine, so blocking here is safe
   - Use `context.Background()` — the request should not be cancelled by D-Bus connection drops
   - Pass `RequestTypeGetSecret`, items with the path, empty session
5. Send `NewRequestMsg{Request, ProcChain}` to TUI via `d.program.Send()`
   - NOTE: RequireApproval creates the request and registers it, but we need the Request object to send to TUI. We need to either:
     - Use `CreateGPGSignRequest`-style non-blocking creation + manual wait, OR
     - Create the request manually, register it, then block on its done channel
   - RECOMMENDED: Create a new method on Manager for the daemon use case: `RequestAndWait(ctx, items, senderInfo, reqType) (*Request, error)` that returns the Request object AND blocks. OR: use the existing non-blocking CreateGPGSignRequest pattern for secrets too.
   - PRAGMATIC APPROACH: Create the request via a new `CreateSecretRequest(client string, path string, senderInfo SenderInfo) (string, *Request, error)` on Manager that returns the request ID and a pointer to the request. Then manually wait on the done channel in the handler. This avoids modifying the existing RequireApproval signature.
   - SIMPLEST APPROACH: Since D-Bus gives us the sender, and we need the Request for the TUI, add a new `Manager.CreateRequest(...)` that stores the request and returns it without blocking. Then the handler sends to TUI and waits on `<-req.Done()` (needs exported done channel or a Wait method). Looking at the existing code, the done channel is unexported. Add `Manager.Wait(id string) (bool, error)` that blocks on the request's done channel.

Steps in handler:
```go
func (d *Dispatcher) RequestSecret(sender dbus.Sender, path string) (string, *dbus.Error) {
    senderInfo := d.resolver.Resolve(string(sender))
    chain := procchain.Walk(senderInfo.PID, 5)

    // Create request (non-blocking) — returns ID and request pointer
    id, err := d.mgr.CreateSecretRequest("dbus", path, senderInfo)
    if err != nil {
        return "", makeDBusError("net.mowaka.Error.Internal", err.Error())
    }

    // Notify TUI
    req := d.mgr.GetPending(id)
    if req != nil {
        d.program.Send(NewRequestMsg{Request: req, ProcChain: chain})
    }

    // Block until resolved
    result, err := d.waitForRequest(id)
    if err != nil {
        if errors.Is(err, approval.ErrTimeout) {
            return "", makeDBusError("net.mowaka.Error.Timeout",
                fmt.Sprintf("Request timed out — approve on VT (Ctrl+Alt+F8)"))
        }
        return "", makeDBusError("net.mowaka.Error.Internal", err.Error())
    }
    if !result {
        return "", makeDBusError("net.mowaka.Error.Denied", "Request denied by user")
    }

    // TODO: In Phase 6+, fetch the actual secret from gopass here.
    // For Phase 5, return a placeholder confirming approval worked.
    return "approved:" + path, nil
}
```

Create `Manager.CreateSecretRequest(client, path string, senderInfo SenderInfo) (string, error)` — similar to `CreateGPGSignRequest` but for get_secret type. Non-blocking. Starts timeout goroutine. Returns request ID.

Create `waitForRequest(id string) (bool, error)` helper on Dispatcher:
- Get request from manager
- Wait on done channel with a select (done, or context, or timeout)
- Actually, the timeout is already handled by the Manager's timeout goroutine. The handler just needs to block until the done channel closes.
- The Manager already has the pattern in CreateGPGSignRequest — the timeout goroutine fires EventRequestExpired. But the handler needs to know when that happens. The simplest bridge: have the handler poll GetPending(id) after done closes... No, the done channel IS the signal. When done closes, check req.result.
- PROBLEM: req.result and req.done are unexported fields. We need either: (a) export them, (b) add a Wait(id) method to Manager, or (c) pass a channel to the create method.
- BEST APPROACH: Add `Manager.WaitForResult(id string) (approved bool, err error)` that:
  1. Gets the request from pending (under lock)
  2. Releases the lock
  3. Blocks on <-req.done
  4. Returns req.result, nil (or error if not found)

This is cleanest because it keeps the done channel unexported and adds a proper API.

**`RequestSign(sender dbus.Sender, repoName, commitMsg, author, committer, keyID string, changedFiles []string, commitObject string) ([]byte, []byte, *dbus.Error)`**

Returns (signature, gpgStatus, error). Per CONTEXT.md GPG signing flow:

1. Resolve sender info and process chain (same as RequestSecret)
2. Build GPGSignInfo from parameters
3. Call `d.mgr.CreateGPGSignRequest("dbus", info, senderInfo)` (already exists)
4. Send NewRequestMsg to TUI
5. Block via `d.mgr.WaitForResult(id)`
6. On approval: run real gpg using existing GPGRunner interface / gpgsign package. Call gpg with the commit object bytes, return signature + status.
7. On denial: return `net.mowaka.Error.Denied`
8. On timeout: return `net.mowaka.Error.Timeout`

For the GPG signing on approval, the Dispatcher needs a GPG signer. Add to Dispatcher:
```go
type gpgSigner interface {
    Sign(commitObject []byte, keyID string) (signature, status []byte, exitCode int, err error)
}
```

The real implementation wraps `gpgsign.FindRealGPG()` + `exec.Command(gpgPath, ...)`. For Phase 5, create a simple wrapper. The existing `defaultGPGRunner` in `internal/api/handlers.go` has the pattern.

**3. Create `internal/daemon/activation.go`:**

D-Bus service activation file content per RESEARCH.md Pattern 7:

```go
// ActivationFileContent returns the D-Bus service activation file content.
// Install to: /usr/share/dbus-1/system-services/net.mowaka.SecretsDispatcher1.service
func ActivationFileContent() string {
    return `[D-BUS Service]
Name=net.mowaka.SecretsDispatcher1
Exec=/usr/local/bin/secrets-dispatcher daemon
User=secrets-nb
`
}

// ActivationFilePath is the install location for the activation file.
const ActivationFilePath = "/usr/share/dbus-1/system-services/net.mowaka.SecretsDispatcher1.service"
```

Note: The actual companion username varies, so this should be parameterized. Make it a function: `ActivationFileContent(companionUser string) string`.

Helper function `makeDBusError(name, message string) *dbus.Error`:
```go
func makeDBusError(name, msg string) *dbus.Error {
    return &dbus.Error{Name: name, Body: []interface{}{msg}}
}
```
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/daemon/...</automated>
  </verify>
  <done>
    - RequestSecret and RequestSign D-Bus methods compile and implement the full approval flow
    - Denied returns net.mowaka.Error.Denied, timeout returns net.mowaka.Error.Timeout
    - D-Bus activation file content is parameterized for companion username
    - Dispatcher holds approval.Manager, tea.Program, senderResolver references
    - GPG signing on approval uses gpgSigner interface (testable)
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite daemon.Run() to start TUI and wire all components</name>
  <files>
    internal/daemon/daemon.go
  </files>
  <action>
**Rewrite `internal/daemon/daemon.go` Run():**

Expand Config to include all Phase 5 fields:

```go
type Config struct {
    BusAddress    string       // empty = system bus, non-empty = test bus
    Version       string
    VTPath        string       // default: "/dev/tty8"
    LockMode      tui.LockMode // default: tui.LockModeNone
    Timeout       time.Duration // default: 5 * time.Minute
    HistoryMax    int          // default: 100
    CompanionUser string       // e.g. "secrets-nb"

    // Test seams
    VTFile        *os.File     // if non-nil, use instead of opening VTPath (for tests)
    Resolver      senderResolver // if non-nil, use instead of creating from D-Bus conn
}
```

Rewrite `Run(ctx context.Context, cfg Config) error`:

1. **Defaults:** VTPath defaults to "/dev/tty8", Timeout defaults to 5 min, HistoryMax to 100

2. **Create approval.Manager:** `mgr := approval.NewManager(cfg.Timeout, cfg.HistoryMax)`

3. **Open VT:** If cfg.VTFile is non-nil (test mode), use it. Otherwise call `tui.OpenVT(cfg.VTPath)`. Install VT cleanup: `defer tui.CleanupOnSignal(vtFile.Fd())()` — this ensures VT_AUTO is restored on crash.

4. **Create TUI model:** `model := tui.NewModel(tui.Config{...}, mgr.Approve, mgr.Deny)`

5. **Start bubbletea program:**
```go
program := tea.NewProgram(model,
    tea.WithInput(vtFile),
    tea.WithOutput(vtFile),
    tea.WithAltScreen(),
)
```

6. **Subscribe TUI observer to approval manager:**
```go
observer := &tuiObserver{program: program}
mgr.Subscribe(observer)
```

The `tuiObserver` implements `approval.Observer`:
```go
type tuiObserver struct {
    program *tea.Program
}

func (o *tuiObserver) OnEvent(e approval.Event) {
    switch e.Type {
    case approval.EventRequestCreated:
        // Already sent by handler via p.Send; skip to avoid duplicate
    case approval.EventRequestApproved:
        o.program.Send(tui.RequestResolvedMsg{ID: e.Request.ID, Resolution: approval.ResolutionApproved})
    case approval.EventRequestDenied:
        o.program.Send(tui.RequestResolvedMsg{ID: e.Request.ID, Resolution: approval.ResolutionDenied})
    case approval.EventRequestExpired:
        o.program.Send(tui.RequestResolvedMsg{ID: e.Request.ID, Resolution: approval.ResolutionExpired})
    case approval.EventRequestCancelled:
        o.program.Send(tui.RequestResolvedMsg{ID: e.Request.ID, Resolution: approval.ResolutionCancelled})
    }
}
```

7. **Connect to D-Bus:** Same pattern as Phase 4 (system bus or test bus).

8. **Create and export Dispatcher:**
```go
resolver := cfg.Resolver
if resolver == nil {
    resolver = proxy.NewSenderInfoResolver(conn)
}
dispatcher := NewDispatcher(cfg.Version, mgr, resolver)
dispatcher.SetProgram(program)
```

Export dispatcher, introspectable, request name — same pattern as Phase 4 but with updated NewDispatcher signature.

9. **Send sd-notify READY=1**

10. **Run TUI in goroutine:** The TUI's `program.Run()` blocks. Run in a goroutine. When it exits, cancel context.

11. **Block on ctx.Done():** When context cancels, call `program.Quit()` to stop TUI, close D-Bus connection.

```go
// Run TUI in background goroutine
tuiDone := make(chan error, 1)
go func() {
    _, err := program.Run()
    tuiDone <- err
}()

// Block until context cancelled or TUI exits
select {
case <-ctx.Done():
    program.Quit()
    <-tuiDone // wait for TUI to exit
case err := <-tuiDone:
    if err != nil {
        slog.Error("TUI exited with error", "error", err)
    }
}
```

IMPORTANT: The existing Phase 4 integration tests in daemon_test.go test Ping and GetVersion which are unchanged. However, the `NewDispatcher` signature changed — update the test's usage or make the new parameters optional/nilable. RECOMMENDED: update Run to use the new Config, but keep tests working by:
- In tests, pass nil VTFile (skip TUI startup when VTFile is nil AND VTPath is empty)
- Add early return for "headless mode" when no VT is configured — useful for integration tests

Add a headless mode: if VTPath is empty and VTFile is nil, skip TUI startup entirely. The dispatcher still works but without TUI rendering (requests will timeout without user interaction). This is essential for tests.

Make sure the existing Ping/GetVersion tests still pass by using Config{BusAddress: addr, Version: "test"} (VTPath and VTFile both zero-value, so headless mode).
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/daemon/... && go test -race -count=1 ./internal/daemon/...</automated>
  </verify>
  <done>
    - daemon.Run() starts TUI on VT, creates approval.Manager, wires D-Bus dispatcher
    - TUI observer bridges approval events to bubbletea messages
    - Headless mode (no VT) for integration tests preserves Phase 4 test compatibility
    - Existing Ping/GetVersion integration tests still pass
    - D-Bus handlers have access to approval.Manager and tea.Program
    - VT cleanup handlers installed for crash recovery
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go build ./internal/daemon/... && go test -race -count=1 ./internal/daemon/...
```
All existing Phase 4 tests pass. New code compiles. D-Bus handlers are wired.
</verification>

<success_criteria>
- RequestSecret blocks on D-Bus until approval, returns secret path on approve, error on deny/timeout
- RequestSign blocks on D-Bus until approval, returns GPG signature on approve
- Error messages mention VT number for user guidance
- daemon.Run() starts TUI on /dev/ttyN and bridges approval events
- Phase 4 integration tests continue to pass (headless mode)
- D-Bus activation file content available for provisioning
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-flow/05-03-SUMMARY.md`
</output>

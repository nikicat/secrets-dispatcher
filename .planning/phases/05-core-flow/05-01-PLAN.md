---
phase: 05-core-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/procchain/procchain.go
  - internal/procchain/procchain_test.go
  - internal/tui/vt.go
  - internal/tui/vt_test.go
  - internal/companion/provision.go
  - internal/companion/sysfuncs.go
  - internal/companion/check.go
  - internal/companion/check_test.go
  - internal/companion/provision_test.go
autonomous: true
requirements: [VT-01, VT-02, VT-05, VT-09, TEST-01]

must_haves:
  truths:
    - "procchain.Walk returns parent process chain up to 5 levels from /proc traversal"
    - "VT ioctl helpers can engage VT_PROCESS mode and restore VT_AUTO"
    - "VT crash recovery restores VT_AUTO via signal handlers and defers"
    - "Companion user is provisioned with tty group membership"
    - "sd-provision --check validates tty group membership"
  artifacts:
    - path: "internal/procchain/procchain.go"
      provides: "Walk() and ProcInfo type for /proc traversal"
      exports: ["Walk", "ProcInfo"]
    - path: "internal/tui/vt.go"
      provides: "VT ioctl helpers: OpenVT, LockVT, UnlockVT, AckRelease, CleanupOnSignal"
      exports: ["OpenVT", "LockVT", "UnlockVT", "AckRelease", "CleanupOnSignal", "LockMode"]
    - path: "internal/companion/provision.go"
      provides: "tty group membership added to provisioning flow"
      contains: "usermodFunc"
    - path: "internal/companion/check.go"
      provides: "tty group membership check added"
      contains: "tty group"
  key_links:
    - from: "internal/procchain/procchain.go"
      to: "/proc/{pid}/status"
      via: "os.ReadFile"
      pattern: "ReadFile.*proc.*status"
    - from: "internal/tui/vt.go"
      to: "linux VT subsystem"
      via: "syscall.Syscall(SYS_IOCTL)"
      pattern: "syscall\\.Syscall.*SYS_IOCTL"
---

<objective>
Build the foundation utilities for Phase 5: process chain traversal (`procchain` package), VT ioctl helpers with crash recovery, and patch Phase 4 provisioning to add the companion user to the `tty` group.

Purpose: These are independent infrastructure pieces that the TUI (Plan 02) and D-Bus handlers (Plan 03) depend on. Building them first enables parallel development in later waves.

Output: `internal/procchain/` package, `internal/tui/vt.go` helpers, updated provisioning with tty group support.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-core-flow/05-RESEARCH.md
@.planning/phases/04-foundation/04-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From internal/approval/types.go:
```go
type SenderInfo struct {
    Sender   string `json:"sender"`
    PID      uint32 `json:"pid"`
    UID      uint32 `json:"uid"`
    UserName string `json:"user_name"`
    UnitName string `json:"unit_name"`
}
```

From internal/companion/sysfuncs.go (injectable function pattern):
```go
var (
    userAddFunc     = defaultUserAdd
    loginctlFunc    = defaultLoginctl
    userLookupFunc  = defaultUserLookup
    mkdirAllFunc    = os.MkdirAll
    chownFunc       = os.Lchown
    chmodFunc       = os.Chmod
    writeFileFunc   = os.WriteFile
    geteuidFunc     = os.Geteuid
)
```

From internal/companion/provision.go:
```go
type Config struct {
    DesktopUser   string
    CompanionName string
    HomeBase      string
}
func Provision(cfg Config) error
func Check(cfg Config) []CheckResult
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create procchain package and VT ioctl helpers</name>
  <files>
    internal/procchain/procchain.go
    internal/procchain/procchain_test.go
    internal/tui/vt.go
    internal/tui/vt_test.go
  </files>
  <action>
**1. Create `internal/procchain/procchain.go`:**

Define the `ProcInfo` struct and `Walk` function per 05-RESEARCH.md Pattern 5:

```go
type ProcInfo struct {
    PID  uint32
    PPid uint32
    Name string // from /proc/pid/comm (short command name)
    CWD  string // from readlink /proc/pid/cwd (may be empty if inaccessible)
}
```

`Walk(startPID uint32, maxDepth int) []ProcInfo` — traverse /proc/{pid}/status for PPid, /proc/{pid}/comm for name, readlink /proc/{pid}/cwd for working directory. Stop at PID 1 or maxDepth. Use `seen` map to prevent cycles. Handle errors gracefully (partial chain is OK).

Helper `readProc(pid uint32) (ProcInfo, error)`:
- Read `/proc/{pid}/status` — parse "Name:" and "PPid:" lines
- Read `/proc/{pid}/comm` — trim newline for short name (prefer comm over status Name for process name as comm is the actual running command)
- `os.Readlink(fmt.Sprintf("/proc/%d/cwd", pid))` — may fail with permission error, set CWD="" on failure

**2. Create `internal/procchain/procchain_test.go`:**

Test `Walk` with the current process (os.Getpid()). Verify:
- Returns at least 1 entry (self)
- First entry has correct PID
- Name is non-empty
- PPid chain terminates (doesn't loop)
- Walk with maxDepth=1 returns exactly 1 entry
- Walk with PID 0 or PID 999999999 returns empty slice

**3. Create `internal/tui/vt.go`:**

VT ioctl helpers per 05-RESEARCH.md Pattern 2. Define:

```go
type LockMode int
const (
    LockModeNone   LockMode = iota // y/n work anytime, no VT_PROCESS
    LockModeManual                  // user explicitly locks/unlocks
    LockModeAuto                    // auto-lock on select, unlock on move
)
```

Constants from linux/vt.h (verified on this machine):
```go
const (
    vtSetMode     = 0x5602
    vtRelDisp     = 0x5605
    vtModeAuto    = 0x00
    vtModeProcess = 0x01
)
```

Define `vtMode` struct matching `struct vt_mode` from linux/vt.h.

Functions:
- `OpenVT(path string) (*os.File, error)` — opens /dev/ttyN with O_RDWR. Returns the file for bubbletea WithInput/WithOutput.
- `LockVT(fd uintptr) error` — calls VT_SETMODE with VT_PROCESS, SIGUSR1 for relsig, SIGUSR2 for acqsig.
- `UnlockVT(fd uintptr) error` — calls VT_SETMODE with VT_AUTO.
- `AckRelease(fd uintptr) error` — calls VT_RELDISP with value 1 (acknowledge VT switch request from kernel).
- `CleanupOnSignal(fd uintptr) func()` — returns a cleanup function that registers SIGTERM/SIGINT handlers and calls UnlockVT. The returned function should be called via `defer` or on shutdown. Also registers a SIGUSR1 handler goroutine that calls AckRelease. IMPORTANT: SIGKILL is uncatchable; the kernel auto-recovers VT_PROCESS mode when the owning process dies — no handler needed.

Use `golang.org/x/sys/unix` or `syscall` for the ioctl calls (both are available; prefer syscall for consistency with existing codebase).

**4. Create `internal/tui/vt_test.go`:**

Since VT ioctls require a real VT device (not a pty), unit tests should:
- Test `OpenVT` with a non-existent path (returns error)
- Test the `vtMode` struct layout is correct size (unsafe.Sizeof == 8 bytes)
- Test `LockMode` constants have expected values
- Skip VT_SETMODE tests with `t.Skip("requires real VT device")` unless running on a real VT (check with environment variable like `SD_TEST_VT=/dev/tty8`)

Note: Do NOT attempt to test VT ioctls on a pty — they will return ENOTTY. The struct layout test ensures binary compatibility.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/procchain/... ./internal/tui/...</automated>
  </verify>
  <done>
    - procchain.Walk returns process chain for current PID with Name, PPid, CWD fields
    - VT ioctl helpers compile with correct constants from linux/vt.h
    - vtMode struct has correct 8-byte layout
    - All tests pass with race detector
  </done>
</task>

<task type="auto">
  <name>Task 2: Patch provisioning to add companion user to tty group</name>
  <files>
    internal/companion/provision.go
    internal/companion/sysfuncs.go
    internal/companion/check.go
    internal/companion/check_test.go
    internal/companion/provision_test.go
  </files>
  <action>
**1. Add `usermodFunc` to `internal/companion/sysfuncs.go`:**

Add an injectable `usermodFunc` following the same pattern as `userAddFunc`:

```go
var usermodFunc = defaultUsermod

func defaultUsermod(username string, args ...string) error {
    allArgs := append(args, username)
    cmd := exec.Command("usermod", allArgs...)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        return fmt.Errorf("usermod: %w", err)
    }
    return nil
}
```

**2. Update `internal/companion/provision.go`:**

Add a new step between step 2 (user creation) and step 3 (home directory) in `Provision()`:
```go
// 2b. Ensure companion user is in the tty group (required for /dev/ttyN access).
if err := ensureTTYGroup(companionUser); err != nil {
    return fmt.Errorf("ensure tty group: %w", err)
}
```

Implement `ensureTTYGroup(username string) error`:
- Call `usermodFunc(username, "--append", "--groups", "tty")` — this is idempotent (usermod --append with an already-present group is a no-op)
- Log the operation

**3. Update `internal/companion/check.go`:**

Add check #10.5 (renumber: insert after "systemd linger enabled" as check #11): "companion user in tty group"
- Look up the companion user's groups using `userLookupGroupIdsFunc` or parse `/etc/group`
- Simplest: use `user.LookupGroup("tty")` to get tty GID, then `u.GroupIds()` to check membership (but note: `user.GroupIds()` is available since Go 1.22)
- Alternative: just check with a simple function that runs `id -Gn companionUser` or reads `/etc/group`
- For testability, use the existing injectable pattern (add a `userGroupsFunc` or just check group membership inline via `user.LookupGroupIds`)

The simpler approach: add `lookupGroupFunc` injectable var that defaults to `user.LookupGroup`, and a `groupIdsFunc` injectable var that defaults to calling `u.GroupIds()`. But this might be over-engineered.

Pragmatic approach: In Check(), after looking up the user, call `u.GroupIds()` and check if tty GID is in the list. This requires the real user.User from `userLookupFunc` which is already called. If the user lookup failed (check #1 failed), skip this check with a not-applicable message.

Update the total check count comment and the test expectations.

Fix hint on failure: `run: sudo usermod --append --groups tty {companionUser}`

**4. Update `internal/companion/provision_test.go`:**

- Add `usermodFunc` to the `saveOrigFuncs` helper
- Add a test `TestProvision_AddsTTYGroup` that verifies `usermodFunc` is called with `--append`, `--groups`, `tty`
- Update the `noopFuncs()` helper to include `usermodFunc = func(string, ...string) error { return nil }`

**5. Update `internal/companion/check_test.go`:**

- Update `TestCheck_ReturnsExpectedCheckCount` from 10 to 11
- Add test for tty group check passing (mock user with tty group)
- Add test for tty group check failing (mock user without tty group)
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/companion/...</automated>
  </verify>
  <done>
    - Provisioning adds companion user to tty group via usermod --append --groups tty
    - Check() reports 11 checks (was 10), including "companion user in tty group"
    - All companion tests pass including new tty group assertions
    - usermodFunc is injectable and tested without requiring real usermod
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/procchain/... ./internal/tui/... ./internal/companion/...
```
All tests pass. No regressions in existing companion tests.
</verification>

<success_criteria>
- `internal/procchain/` package exists with Walk() returning process chain from /proc
- `internal/tui/vt.go` provides VT ioctl helpers with correct linux/vt.h constants
- Companion provisioning creates user with tty group membership
- `sd-provision --check` validates tty group membership (11 checks total)
- All tests pass with race detector enabled
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-flow/05-01-SUMMARY.md`
</output>

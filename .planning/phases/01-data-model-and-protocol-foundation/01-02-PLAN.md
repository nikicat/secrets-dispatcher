---
phase: 01-data-model-and-protocol-foundation
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - internal/api/gpgsign.go
  - internal/api/types.go
  - internal/api/websocket.go
  - internal/api/handlers.go
  - internal/api/server.go
autonomous: true
requirements:
  - SIGN-06
  - SIGN-09

must_haves:
  truths:
    - "POST /api/v1/gpg-sign/request accepts a JSON body with commit context and returns a request ID"
    - "The gpg_sign request appears in GET /api/v1/pending with its GPGSignInfo fields populated"
    - "When the request is approved, the WebSocket request_resolved event carries a Signature field"
    - "The route is registered in the server mux"
  artifacts:
    - path: "internal/api/gpgsign.go"
      provides: "GPGSignRequest type, GPGSignResponse type, HandleGPGSignRequest handler"
      contains: "HandleGPGSignRequest"
    - path: "internal/api/types.go"
      provides: "GPGSignInfo field on PendingRequest"
      contains: "GPGSignInfo"
    - path: "internal/api/websocket.go"
      provides: "Signature field on WSMessage"
      contains: "Signature"
    - path: "internal/api/server.go"
      provides: "Route registration for /api/v1/gpg-sign/request"
      contains: "gpg-sign/request"
  key_links:
    - from: "internal/api/gpgsign.go"
      to: "internal/approval/gpgsign.go"
      via: "h.manager.CreateGPGSignRequest call"
      pattern: "CreateGPGSignRequest"
    - from: "internal/api/websocket.go"
      to: "internal/api/types.go"
      via: "WSMessage.Signature field set when event request type is gpg_sign"
      pattern: "approval\\.RequestTypeGPGSign"
    - from: "internal/api/handlers.go"
      to: "internal/approval/gpgsign.go"
      via: "GPGSignInfo copied into PendingRequest in HandlePendingList and convertHistoryEntry"
      pattern: "GPGSignInfo:"
---

<objective>
Add the API handler, request/response types, WebSocket extension, serialization, and route registration for the gpg_sign endpoint.

Purpose: Makes the gpg_sign endpoint callable and wires it into the existing pending list, history, and WebSocket broadcast paths so Phase 3 display work is unblocked.
Output: internal/api/gpgsign.go (new), plus targeted extensions to types.go, websocket.go, handlers.go, server.go
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-data-model-and-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-data-model-and-protocol-foundation/01-RESEARCH.md
@.planning/phases/01-data-model-and-protocol-foundation/01-01-SUMMARY.md
@internal/api/handlers.go
@internal/api/types.go
@internal/api/websocket.go
@internal/api/server.go
@internal/approval/gpgsign.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add API types, handler, and route registration</name>
  <files>
    internal/api/gpgsign.go
    internal/api/server.go
  </files>
  <action>
Create `internal/api/gpgsign.go` in package `api`:

```go
// GPGSignRequest is the POST body for /api/v1/gpg-sign/request.
type GPGSignRequest struct {
    Client      string                  `json:"client"`
    GPGSignInfo *approval.GPGSignInfo   `json:"gpg_sign_info"`
}

// GPGSignResponse is the response body for a successful POST to /api/v1/gpg-sign/request.
type GPGSignResponse struct {
    RequestID string `json:"request_id"`
}
```

Add handler on `*Handlers`:

```go
// HandleGPGSignRequest handles POST /api/v1/gpg-sign/request.
// It creates a non-blocking gpg_sign approval request and returns the request ID.
// The result (signature or denial) is delivered via the WebSocket request_resolved event.
func (h *Handlers) HandleGPGSignRequest(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        writeError(w, "method not allowed", http.StatusMethodNotAllowed)
        return
    }
    var req GPGSignRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeError(w, "invalid request body", http.StatusBadRequest)
        return
    }
    if req.GPGSignInfo == nil {
        writeError(w, "gpg_sign_info is required", http.StatusBadRequest)
        return
    }
    if req.Client == "" {
        req.Client = "unknown"
    }
    id, err := h.manager.CreateGPGSignRequest(req.Client, req.GPGSignInfo)
    if err != nil {
        writeError(w, err.Error(), http.StatusInternalServerError)
        return
    }
    writeJSON(w, GPGSignResponse{RequestID: id})
}
```

Imports: `"encoding/json"`, `"net/http"`, `"github.com/nb/secrets-dispatcher/internal/approval"` (match existing import path from handlers.go).

In `internal/api/server.go`, add inside `newServerWithHandlers` alongside existing routes:
```go
apiMux.HandleFunc("/api/v1/gpg-sign/request", handlers.HandleGPGSignRequest)
```
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/api/...</automated>
  </verify>
  <done>go build ./internal/api/... exits 0; HandleGPGSignRequest exists; route registered in server.go</done>
</task>

<task type="auto">
  <name>Task 2: Extend WSMessage, PendingRequest, and conversion functions for gpg_sign</name>
  <files>
    internal/api/types.go
    internal/api/websocket.go
    internal/api/handlers.go
  </files>
  <action>
**internal/api/types.go** — add to `PendingRequest` struct:
```go
GPGSignInfo *approval.GPGSignInfo `json:"gpg_sign_info,omitempty"`
```
Use `*approval.GPGSignInfo` directly (do NOT redeclare the fields — avoid the SenderInfo duplication anti-pattern noted in RESEARCH.md).

**internal/api/websocket.go** — add to `WSMessage` struct:
```go
// Signature carries base64-encoded signature bytes for gpg_sign request_resolved events.
// Empty for all other event types.
Signature string `json:"signature,omitempty"`
```

In the WebSocket `OnEvent` handler (the function/method that constructs `WSMessage` from `approval.Event`): when the event type is `EventRequestApproved` and the request type is `approval.RequestTypeGPGSign`, set `msg.Signature = base64.StdEncoding.EncodeToString([]byte("PLACEHOLDER_SIGNATURE"))`. Import `"encoding/base64"` if not already present.

**internal/api/handlers.go** — there are exactly two conversion sites per RESEARCH.md:
1. `HandlePendingList` — in the loop that builds `PendingRequest` from `approval.Request`, add: `GPGSignInfo: r.GPGSignInfo`
2. `convertHistoryEntry` — in the body that builds from `approval.Request`, add: `GPGSignInfo: req.GPGSignInfo`

Both sites use the same field assignment pattern. Do NOT change any other logic in these functions.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./...</automated>
  </verify>
  <done>go build ./... and go vet ./... exit 0; WSMessage has Signature field; PendingRequest has GPGSignInfo field; both conversion sites updated</done>
</task>

</tasks>

<verification>
cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./...

Both must exit 0. Grep checks:
- grep -r "gpg-sign/request" internal/api/server.go — must find the route
- grep -r "Signature" internal/api/websocket.go — must find the field
- grep -r "GPGSignInfo" internal/api/handlers.go — must find both conversion sites
</verification>

<success_criteria>
1. POST /api/v1/gpg-sign/request route registered in server.go
2. HandleGPGSignRequest in internal/api/gpgsign.go calls h.manager.CreateGPGSignRequest
3. WSMessage.Signature field exists in websocket.go
4. PendingRequest.GPGSignInfo field exists in types.go
5. HandlePendingList and convertHistoryEntry both propagate GPGSignInfo
6. go build ./... exits 0
7. go vet ./... exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-model-and-protocol-foundation/01-02-SUMMARY.md`
</output>

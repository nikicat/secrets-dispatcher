---
phase: 02-core-signing-flow
plan: "04"
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - internal/gpgsign/daemon.go
  - internal/gpgsign/run.go
  - internal/gpgsign/setup.go
  - main.go
autonomous: true
requirements:
  - SIGN-01
  - SIGN-03
  - SIGN-04
  - SIGN-05
  - SIGN-08
  - ERR-01

must_haves:
  truths:
    - "gpg-sign subcommand reads commit object from stdin, collects git context, sends to daemon, and blocks until resolved"
    - "Thin client connects to daemon via Unix socket using HTTP-over-Unix-socket transport"
    - "WebSocket connection is established BEFORE POST to avoid missing the resolution event"
    - "Denied requests exit 1, unreachable daemon exits 2, gpg failures exit with gpg's exit code"
    - "gpg-sign setup writes a shell wrapper script and configures git gpg.program"
    - "Signature written to stdout, GPG status written to stderr on successful approval"
  artifacts:
    - path: "internal/gpgsign/run.go"
      provides: "Run() entry point for gpg-sign subcommand"
      exports: ["Run"]
    - path: "internal/gpgsign/daemon.go"
      provides: "DaemonClient for HTTP+WS over Unix socket"
      contains: "DaemonClient"
    - path: "internal/gpgsign/setup.go"
      provides: "SetupGitConfig for gpg-sign setup command"
      exports: ["SetupGitConfig"]
    - path: "main.go"
      provides: "gpg-sign and gpg-sign setup subcommand routing"
      contains: "gpg-sign"
  key_links:
    - from: "internal/gpgsign/run.go"
      to: "internal/gpgsign/daemon.go"
      via: "Run calls DaemonClient methods"
      pattern: "DaemonClient"
    - from: "internal/gpgsign/daemon.go"
      to: "internal/api/server.go"
      via: "HTTP-over-Unix-socket to daemon's Unix listener"
      pattern: "unix.*DialContext"
    - from: "main.go"
      to: "internal/gpgsign/run.go"
      via: "main dispatches gpg-sign subcommand to gpgsign.Run"
      pattern: "gpgsign\\.Run"
    - from: "internal/gpgsign/run.go"
      to: "internal/gpgsign/commit.go"
      via: "Run calls ParseCommitObject"
      pattern: "ParseCommitObject"
---

<objective>
Implement the thin client: DaemonClient (HTTP+WS over Unix socket), Run() entry point that intercepts git's gpg call and blocks until approved/denied, SetupGitConfig command, and main.go subcommand wiring.

Purpose: This is the user-facing thin client that git calls as `gpg.program`. It completes the signing pipeline from `git commit -S` through to signature delivery.

Output: Working `secrets-dispatcher gpg-sign` subcommand and `secrets-dispatcher gpg-sign setup` command. The daemon-side Unix socket and real GPG invocation are from Plans 01 and 03.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-signing-flow/02-RESEARCH.md
@.planning/phases/02-core-signing-flow/02-01-SUMMARY.md
@.planning/phases/02-core-signing-flow/02-02-SUMMARY.md

@internal/gpgsign/commit.go
@internal/gpgsign/gpg.go
@internal/approval/gpgsign.go
@internal/api/server.go
@internal/api/auth.go
@internal/api/websocket.go
@internal/api/types.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DaemonClient and Run() entry point</name>
  <files>
    internal/gpgsign/daemon.go
    internal/gpgsign/run.go
  </files>
  <action>
**internal/gpgsign/daemon.go — DaemonClient:**

Create a `DaemonClient` struct that communicates with the daemon over a Unix socket:

```go
package gpgsign

import (
    "context"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "net"
    "net/http"

    "github.com/coder/websocket"
    "github.com/nikicat/secrets-dispatcher/internal/approval"
)

// DaemonClient communicates with the secrets-dispatcher daemon over a Unix socket.
type DaemonClient struct {
    socketPath string
    token      string
    httpClient *http.Client
}

// NewDaemonClient creates a client connected to the daemon's Unix socket.
func NewDaemonClient(socketPath, token string) *DaemonClient {
    transport := &http.Transport{
        DialContext: func(ctx context.Context, _, _ string) (net.Conn, error) {
            return (&net.Dialer{}).DialContext(ctx, "unix", socketPath)
        },
    }
    return &DaemonClient{
        socketPath: socketPath,
        token:      token,
        httpClient: &http.Client{Transport: transport},
    }
}
```

Methods on DaemonClient:

1. `DialWebSocket(ctx context.Context) (*websocket.Conn, error)` — opens WebSocket to `ws://localhost/api/v1/ws` with Bearer auth header via the Unix socket transport:
   ```go
   func (c *DaemonClient) DialWebSocket(ctx context.Context) (*websocket.Conn, error) {
       conn, _, err := websocket.Dial(ctx, "ws://localhost/api/v1/ws", &websocket.DialOptions{
           HTTPClient: c.httpClient,
           HTTPHeader: http.Header{
               "Authorization": {"Bearer " + c.token},
           },
       })
       return conn, err
   }
   ```

2. `PostSigningRequest(ctx context.Context, client string, info *approval.GPGSignInfo) (string, error)` — POST to `/api/v1/gpg-sign/request` with Bearer auth, returns request ID:
   ```go
   func (c *DaemonClient) PostSigningRequest(ctx context.Context, client string, info *approval.GPGSignInfo) (string, error) {
       body := struct {
           Client      string               `json:"client"`
           GPGSignInfo *approval.GPGSignInfo `json:"gpg_sign_info"`
       }{Client: client, GPGSignInfo: info}
       // Marshal, POST, decode GPGSignResponse, return request_id
   }
   ```

3. `WaitForResolution(ctx context.Context, conn *websocket.Conn, requestID string) (signature, gpgStatus []byte, exitCode int, denied bool, err error)` — reads WebSocket messages until matching `request_resolved` or `request_expired`:
   - For each message: unmarshal, check type and ID
   - On `request_resolved` with matching ID:
     - If `result == "approved"` and `exit_code == 0`: decode base64 signature, return (signature, gpgStatus, 0, false, nil)
     - If `result == "approved"` and `exit_code != 0`: return (nil, gpgStatus, exitCode, false, nil) — gpg failed
     - If `result == "denied"`: return (nil, nil, 0, true, nil)
   - On `request_expired` with matching ID: return with a timeout error
   - Other messages or non-matching IDs: continue reading

Define a local struct for parsing WSMessages (don't import api package to avoid circular deps):
```go
type wsMsg struct {
    Type      string `json:"type"`
    ID        string `json:"id,omitempty"`
    Result    string `json:"result,omitempty"`
    Signature string `json:"signature,omitempty"`
    GPGStatus string `json:"gpg_status,omitempty"`
    ExitCode  int    `json:"exit_code,omitempty"`
}
```

**internal/gpgsign/run.go — Run() entry point:**

```go
package gpgsign

import (
    "context"
    "fmt"
    "io"
    "os"
    "os/exec"
    "path/filepath"
    "strings"

    "github.com/nikicat/secrets-dispatcher/internal/approval"
)

// Run is the entry point for the gpg-sign subcommand.
// It is called by git as: secrets-dispatcher gpg-sign --status-fd=2 -bsau <keyID>
// with the raw commit object on stdin.
// Returns the process exit code.
func Run(args []string, stdin io.Reader) int {
    debug := os.Getenv("SECRETS_DISPATCHER_DEBUG") == "1"

    // 1. Parse key ID from args (SIGN-02 partial)
    keyID := extractKeyID(args)
    if debug {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: debug: keyID=%s args=%v\n", keyID, args)
    }

    // 2. Read commit object from stdin (SIGN-02)
    commitBytes, err := io.ReadAll(stdin)
    if err != nil {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: failed to read stdin: %v\n", err)
        return 2
    }

    // 3. Parse commit object for context (SIGN-02)
    author, committer, message, parentHash := ParseCommitObject(commitBytes)

    // 4. Collect git context (SIGN-03, SIGN-04)
    repoName := resolveRepoName(debug)
    changedFiles := collectChangedFiles(debug)

    // 5. Load auth token (ERR-01 if missing)
    token, err := loadAuthToken()
    if err != nil {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: daemon not running (cannot read auth token): %v\n", err)
        return 2
    }

    // 6. Determine socket path
    socketPath := unixSocketPath()
    if debug {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: debug: socket=%s\n", socketPath)
    }

    // 7. Create daemon client
    client := NewDaemonClient(socketPath, token)
    ctx := context.Background()

    // 8. WebSocket FIRST (CONTEXT locked decision: ensures no missed events)
    wsConn, err := client.DialWebSocket(ctx)
    if err != nil {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: daemon unreachable at %s. Is secrets-dispatcher running?\n", socketPath)
        return 2
    }
    defer wsConn.CloseNow()

    // 9. POST signing request (SIGN-05)
    reqID, err := client.PostSigningRequest(ctx, repoName, &approval.GPGSignInfo{
        RepoName:     repoName,
        CommitMsg:    message,
        Author:       author,
        Committer:    committer,
        KeyID:        keyID,
        ChangedFiles: changedFiles,
        ParentHash:   parentHash,
        CommitObject: string(commitBytes),
    })
    if err != nil {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: failed to send signing request: %v\n", err)
        return 2
    }

    if debug {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: debug: request_id=%s\n", reqID)
    }

    // 10. Wait for resolution (SIGN-08, ERR-01, ERR-02)
    signature, gpgStatus, exitCode, denied, err := client.WaitForResolution(ctx, wsConn, reqID)
    if err != nil {
        fmt.Fprintf(os.Stderr, "secrets-dispatcher: %v\n", err)
        return 2
    }

    if denied {
        fmt.Fprintln(os.Stderr, "secrets-dispatcher: signing request denied by user")
        return 1
    }

    if exitCode != 0 {
        // ERR-02: propagate gpg exit code
        if len(gpgStatus) > 0 {
            os.Stderr.Write(gpgStatus)
        }
        return exitCode
    }

    // SIGN-08: Write signature to stdout, status to stderr
    os.Stdout.Write(signature)
    if len(gpgStatus) > 0 {
        os.Stderr.Write(gpgStatus)
    }
    return 0
}
```

Helper functions in run.go:

- `resolveRepoName(debug bool) string` — runs `git rev-parse --show-toplevel`, returns `filepath.Base(result)`. On error, returns "unknown" and logs if debug.
- `collectChangedFiles(debug bool) []string` — runs `git diff --cached --name-only`, splits by newline, filters empty strings. On error, returns nil and logs if debug.
- `loadAuthToken() (string, error)` — reads `$XDG_STATE_HOME/secrets-dispatcher/.cookie` (or `~/.local/state/secrets-dispatcher/.cookie` if XDG_STATE_HOME unset). Returns trimmed token or error.
- `unixSocketPath() string` — returns `$XDG_RUNTIME_DIR/secrets-dispatcher/api.sock`. If XDG_RUNTIME_DIR unset, returns `/run/user/<uid>/secrets-dispatcher/api.sock` with uid from os.Getuid().

Exit code semantics (from CONTEXT.md locked decisions):
- 0: success (signature written to stdout)
- 1: user denied or request timed out
- 2: system error (daemon unreachable, auth token missing, etc.)
- Other: gpg's exit code (ERR-02)

IMPORTANT: Use `os.Stderr.Write()` for gpg status, not fmt.Fprintln — the status bytes must be written verbatim without added newlines.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./...</automated>
  </verify>
  <done>Run() reads stdin, parses commit, connects to daemon via Unix socket (WS first, then POST), waits for resolution, writes signature to stdout and status to stderr. Exit codes match CONTEXT.md spec. DaemonClient handles all HTTP+WS communication.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SetupGitConfig and wire subcommands in main.go</name>
  <files>
    internal/gpgsign/setup.go
    main.go
  </files>
  <action>
**internal/gpgsign/setup.go — SetupGitConfig:**

```go
package gpgsign

import (
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
)

// SetupGitConfig writes a shell wrapper script and configures git's gpg.program.
// scope is "global" (default) or "local" (per-repo).
//
// A wrapper script is required because git does NOT shell-split gpg.program —
// it uses execvp, so "secrets-dispatcher gpg-sign" (with space) fails.
// The wrapper calls: exec secrets-dispatcher gpg-sign "$@"
func SetupGitConfig(scope string) error {
    self, err := os.Executable()
    if err != nil {
        return fmt.Errorf("find executable: %w", err)
    }
    // Resolve symlinks so the wrapper calls the real binary
    self, err = filepath.EvalSymlinks(self)
    if err != nil {
        return fmt.Errorf("resolve executable: %w", err)
    }

    // Write shell wrapper to ~/.local/bin/secrets-dispatcher-gpg
    home, err := os.UserHomeDir()
    if err != nil {
        return fmt.Errorf("get home dir: %w", err)
    }
    wrapperDir := filepath.Join(home, ".local", "bin")
    wrapperPath := filepath.Join(wrapperDir, "secrets-dispatcher-gpg")

    if err := os.MkdirAll(wrapperDir, 0755); err != nil {
        return fmt.Errorf("create wrapper dir: %w", err)
    }

    content := fmt.Sprintf("#!/bin/sh\nexec %s gpg-sign \"$@\"\n", self)
    if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
        return fmt.Errorf("write wrapper: %w", err)
    }

    // Configure git
    gitArgs := []string{"config"}
    if scope == "local" {
        gitArgs = append(gitArgs, "--local")
    } else {
        gitArgs = append(gitArgs, "--global")
    }
    gitArgs = append(gitArgs, "gpg.program", wrapperPath)
    if err := exec.Command("git", gitArgs...).Run(); err != nil {
        return fmt.Errorf("git config: %w", err)
    }

    fmt.Printf("Wrote wrapper: %s\n", wrapperPath)
    fmt.Printf("Configured git %s gpg.program = %s\n", scope, wrapperPath)
    fmt.Println("\nNote: Ensure ~/.local/bin is in your PATH.")
    fmt.Println("This does NOT enable commit.gpgsign — use 'git config --global commit.gpgsign true' to auto-sign all commits.")
    return nil
}
```

Per CONTEXT.md locked decisions:
- Setup only sets gpg.program — does NOT enable commit.gpgsign=true
- Setup defaults to --global; user can pass --local

**main.go — wire subcommands:**

Add `"gpg-sign"` case in the switch statement in main():

```go
case "gpg-sign":
    runGPGSign(os.Args[2:])
```

Add the `runGPGSign` function:

```go
func runGPGSign(args []string) {
    // Check for "setup" subcommand
    if len(args) > 0 && args[0] == "setup" {
        runGPGSignSetup(args[1:])
        return
    }

    // Regular gpg-sign invocation: git calls us with gpg args and stdin
    os.Exit(gpgsign.Run(args, os.Stdin))
}

func runGPGSignSetup(args []string) {
    fs := flag.NewFlagSet("gpg-sign setup", flag.ExitOnError)
    local := fs.Bool("local", false, "Configure per-repo (--local) instead of --global")
    fs.Parse(args)

    scope := "global"
    if *local {
        scope = "local"
    }

    if err := gpgsign.SetupGitConfig(scope); err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
}
```

Add import for `"github.com/nikicat/secrets-dispatcher/internal/gpgsign"` in main.go.

Update `printUsage()` to include:
```
  gpg-sign  GPG signing proxy (called by git as gpg.program)
  gpg-sign setup  Configure git to use secrets-dispatcher for GPG signing
```

Also, pass the Unix socket path to the server when starting. In `runServe`:
- After setting up the state directory, compute the socket path: `socketPath := filepath.Join(runtimeDir, "secrets-dispatcher", "api.sock")` where runtimeDir comes from getSocketsDir's XDG_RUNTIME_DIR logic (or reuse the existing function).
- Pass socketPath as an additional parameter to `api.NewServer` / `api.NewServerWithProvider`. This requires updating these constructors to accept the socket path — which was prepared in Plan 01 (Task 2 modified newServerWithHandlers to accept unixSocketPath).
- If `--api-only` mode: skip Unix socket (pass empty string).

The exact wiring: after `apiServer` is created, call the server's method or pass via constructor. Follow the pattern established in Plan 01 Task 2.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./... -timeout 60s</automated>
  </verify>
  <done>main.go routes `gpg-sign` to gpgsign.Run() and `gpg-sign setup` to gpgsign.SetupGitConfig(). The server starts a Unix socket listener when running in serve mode. `secrets-dispatcher gpg-sign --help` and `secrets-dispatcher gpg-sign setup --help` work. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./... -timeout 60s
# Verify subcommand routing works:
cd /home/nb/src/secrets-dispatcher && go run . gpg-sign setup --help 2>&1 | head -5
```
Binary builds. Subcommands are routed correctly. All tests pass.
</verification>

<success_criteria>
1. `secrets-dispatcher gpg-sign` reads stdin commit object, parses it, and attempts to connect to daemon
2. `secrets-dispatcher gpg-sign setup` writes wrapper script and configures git
3. `secrets-dispatcher gpg-sign setup --local` uses --local scope
4. Thin client connects via Unix socket with Bearer token auth
5. WebSocket opened BEFORE POST (locked decision)
6. Exit codes: 0 (success), 1 (denied/timeout), 2 (system error), N (gpg exit code)
7. Signature written to stdout, GPG status to stderr
8. `go build ./...` succeeds, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-signing-flow/02-04-SUMMARY.md`
</output>

---
phase: 01-data-model-and-protocol-foundation
plan: "03"
type: tdd
wave: 3
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - internal/approval/gpgsign_test.go
  - internal/api/gpgsign_test.go
autonomous: true
requirements:
  - SIGN-06
  - SIGN-09
  - ERR-03

must_haves:
  truths:
    - "CreateGPGSignRequest returns a non-empty request ID and the request appears in pending list"
    - "gpg_sign request expires and fires EventRequestExpired after manager timeout"
    - "POST /api/v1/gpg-sign/request with valid body returns 200 with a request_id"
    - "POST /api/v1/gpg-sign/request with missing gpg_sign_info returns 400"
    - "Approved gpg_sign request produces a WSMessage with non-empty Signature"
    - "Key ID field from GPGSignInfo is visible in the pending request returned by HandlePendingList"
  artifacts:
    - path: "internal/approval/gpgsign_test.go"
      provides: "Manager-level tests for CreateGPGSignRequest and expiry"
      contains: "TestCreateGPGSignRequest"
    - path: "internal/api/gpgsign_test.go"
      provides: "HTTP handler tests for HandleGPGSignRequest"
      contains: "TestHandleGPGSignRequest"
  key_links:
    - from: "internal/approval/gpgsign_test.go"
      to: "internal/approval/gpgsign.go"
      via: "calls manager.CreateGPGSignRequest and inspects returned ID and pending map"
      pattern: "CreateGPGSignRequest"
    - from: "internal/api/gpgsign_test.go"
      to: "internal/api/gpgsign.go"
      via: "httptest.NewRecorder POST to handler, assert response JSON"
      pattern: "HandleGPGSignRequest"
---

<objective>
Write unit tests that verify the gpg_sign data model, manager method, HTTP handler, and WebSocket event extension all behave correctly.

Purpose: TDD verification — tests prove Phase 1 contracts hold before Phase 2 builds on them.
Output: internal/approval/gpgsign_test.go, internal/api/gpgsign_test.go
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-data-model-and-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-data-model-and-protocol-foundation/01-01-SUMMARY.md
@.planning/phases/01-data-model-and-protocol-foundation/01-02-SUMMARY.md
@internal/approval/gpgsign.go
@internal/approval/manager.go
@internal/api/gpgsign.go
@internal/api/handlers.go
</context>

<feature>
  <name>gpg_sign approval model and HTTP handler</name>
  <files>internal/approval/gpgsign_test.go, internal/api/gpgsign_test.go</files>
  <behavior>
Manager layer (internal/approval/gpgsign_test.go):

Case 1: CreateGPGSignRequest with valid GPGSignInfo
  - Returns non-empty string ID, nil error
  - Request appears in manager.pending (use the manager's list/pending accessor if available, or call HandlePendingList via httptest)
  - EventRequestCreated observer event fires with the new request's ID

Case 2: CreateGPGSignRequest with nil GPGSignInfo
  - Returns "", non-nil error

Case 3: gpg_sign request expiry (ERR-03)
  - Create manager with very short timeout (e.g. 50ms via NewManager or test helper)
  - Call CreateGPGSignRequest
  - After timeout elapses, EventRequestExpired fires for the request ID
  - Request is no longer in pending

Case 4: Approve a gpg_sign request
  - CreateGPGSignRequest, then Approve(id)
  - EventRequestApproved fires
  - Request removed from pending

Case 5: Deny a gpg_sign request
  - CreateGPGSignRequest, then Deny(id)
  - EventRequestDenied fires

HTTP handler layer (internal/api/gpgsign_test.go):

Case 6: POST with valid body
  - Body: {"client":"test","gpg_sign_info":{"repo_name":"myrepo","commit_msg":"fix: thing","author":"A","committer":"A","key_id":"ABCD1234","changed_files":["main.go"]}}
  - Response: 200, {"request_id": "..."}
  - request_id is non-empty UUID

Case 7: POST with missing gpg_sign_info
  - Body: {"client":"test"}
  - Response: 400

Case 8: Wrong HTTP method (GET)
  - Response: 405

Case 9: Key ID visible in pending list (SIGN-09)
  - After successful POST, call HandlePendingList
  - Response includes item with gpg_sign_info.key_id = "ABCD1234"

Case 10: WSMessage Signature field set on approval
  - Subscribe to manager events
  - CreateGPGSignRequest, then Approve(id)
  - Simulate the WebSocket OnEvent path: when EventRequestApproved fires for a gpg_sign request, the constructed WSMessage has non-empty Signature field
  </behavior>
  <implementation>
Use `httptest.NewRecorder` and `httptest.NewRequest` for HTTP cases. For manager cases, instantiate a real Manager with `approval.NewManager` (check constructor signature in manager.go) with a short timeout for expiry tests. Subscribe an event channel via the existing Subscribe/observer mechanism. Do not mock the manager in handler tests — use a real Manager instance wired into real Handlers (matching the pattern used in existing handler tests, if any, else use the same setup pattern as production code).

Look at existing test files (if any) in internal/approval/ and internal/api/ for the test helper pattern before writing from scratch.
  </implementation>
</feature>

<verification>
<automated>cd /home/nb/src/secrets-dispatcher && go test ./internal/approval/... ./internal/api/... -v -run "GPGSign|GPGsign|gpgsign" -timeout 10s</automated>
<manual>All test cases listed in behavior section pass. No skipped tests.</manual>
</verification>

<success_criteria>
1. go test ./internal/approval/... ./internal/api/... exits 0
2. All 10 behavioral cases have corresponding test functions
3. Expiry test (Case 3) passes with a short timeout without sleeping more than 200ms
4. No new external test dependencies (use only stdlib testing + httptest)
5. go build ./... still exits 0 after tests are added
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-model-and-protocol-foundation/01-03-SUMMARY.md`
</output>

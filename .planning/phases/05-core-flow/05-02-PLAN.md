---
phase: 05-core-flow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/tui/model.go
  - internal/tui/list_pane.go
  - internal/tui/detail_pane.go
  - internal/tui/styles.go
  - internal/tui/messages.go
  - internal/tui/model_test.go
  - go.mod
  - go.sum
autonomous: true
requirements: [VT-03, VT-04, VT-06, TEST-01]

must_haves:
  truths:
    - "TUI renders a two-pane layout with request list on left and detail on right"
    - "Secret requests display path, PID/UID, process name, working directory, process chain"
    - "GPG signing requests display repo name, commit message, author, changed files, stat summary, key ID"
    - "y/n keystrokes approve or deny the selected request"
    - "New requests appear in list without stealing focus"
    - "Resolved requests appear in dimmed recent history section"
    - "Live countdown timer shown per item in left pane"
  artifacts:
    - path: "internal/tui/model.go"
      provides: "Root bubbletea model with Elm architecture"
      exports: ["Model", "NewModel", "NewRequestMsg", "RequestResolvedMsg"]
    - path: "internal/tui/list_pane.go"
      provides: "Left pane: request list with type badges, countdown, history"
      exports: ["requestItem"]
    - path: "internal/tui/detail_pane.go"
      provides: "Right pane: full request context rendering"
      exports: ["detailPane"]
    - path: "internal/tui/styles.go"
      provides: "lipgloss style definitions"
    - path: "internal/tui/messages.go"
      provides: "bubbletea message types for TUI communication"
      exports: ["NewRequestMsg", "RequestResolvedMsg", "TickMsg"]
  key_links:
    - from: "internal/tui/model.go"
      to: "internal/approval"
      via: "approval.Request type used in messages"
      pattern: "approval\\.Request"
    - from: "internal/tui/model.go"
      to: "bubbletea event loop"
      via: "tea.Model interface (Init, Update, View)"
      pattern: "func.*model.*Update.*tea\\.Msg"
---

<objective>
Build the bubbletea TUI that renders on the companion VT. The TUI has a two-pane master-detail layout: left pane shows a request list with type badges and countdown timers, right pane shows full request context. Supports y/n keystrokes for approve/deny, resolved request history, and VT lock mode awareness.

Purpose: This is the user-facing approval interface on the dedicated VT. It must render rich context so users can make informed approval decisions without needing to switch to their desktop.

Output: `internal/tui/` package with model, panes, styles, messages, and unit tests.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-core-flow/05-CONTEXT.md
@.planning/phases/05-core-flow/05-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From internal/approval/manager.go:
```go
type Request struct {
    ID        string     `json:"id"`
    Client    string     `json:"client"`
    Items     []ItemInfo `json:"items"`
    Session   string     `json:"session"`
    CreatedAt time.Time  `json:"created_at"`
    ExpiresAt time.Time  `json:"expires_at"`
    Type      RequestType `json:"type"`
    SearchAttributes map[string]string `json:"search_attributes,omitempty"`
    SenderInfo SenderInfo `json:"sender_info"`
    GPGSignInfo *GPGSignInfo `json:"gpg_sign_info,omitempty"`
    // ... unexported fields
}

type EventType int
const (
    EventRequestCreated EventType = iota
    EventRequestApproved
    EventRequestDenied
    EventRequestExpired
    EventRequestCancelled
)

type Event struct {
    Type    EventType
    Request *Request
}

type Observer interface {
    OnEvent(Event)
}

func (m *Manager) Subscribe(o Observer)
func (m *Manager) Approve(id string) error
func (m *Manager) Deny(id string) error
func (m *Manager) List() []*Request
```

From internal/approval/types.go:
```go
type SenderInfo struct {
    Sender   string `json:"sender"`
    PID      uint32 `json:"pid"`
    UID      uint32 `json:"uid"`
    UserName string `json:"user_name"`
    UnitName string `json:"unit_name"`
}
```

From internal/approval/gpgsign.go:
```go
type GPGSignInfo struct {
    RepoName     string   `json:"repo_name"`
    CommitMsg    string   `json:"commit_msg"`
    Author       string   `json:"author"`
    Committer    string   `json:"committer"`
    KeyID        string   `json:"key_id"`
    Fingerprint  string   `json:"fingerprint,omitempty"`
    ChangedFiles []string `json:"changed_files"`
    ParentHash   string   `json:"parent_hash,omitempty"`
    CommitObject string   `json:"commit_object,omitempty"`
}
```

From internal/procchain/procchain.go (created in Plan 01):
```go
type ProcInfo struct {
    PID  uint32
    PPid uint32
    Name string
    CWD  string
}
func Walk(startPID uint32, maxDepth int) []ProcInfo
```

From internal/tui/vt.go (created in Plan 01):
```go
type LockMode int
const (
    LockModeNone   LockMode = iota
    LockModeManual
    LockModeAuto
)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TUI message types, styles, and pane components</name>
  <files>
    internal/tui/messages.go
    internal/tui/styles.go
    internal/tui/list_pane.go
    internal/tui/detail_pane.go
    go.mod
    go.sum
  </files>
  <action>
First, add bubbletea and lipgloss dependencies:
```bash
cd /home/nb/src/secrets-dispatcher && go get github.com/charmbracelet/bubbletea@latest github.com/charmbracelet/lipgloss@latest github.com/charmbracelet/bubbles@latest
```

**1. Create `internal/tui/messages.go`:**

Define bubbletea message types for inter-component communication:

```go
// NewRequestMsg is sent via p.Send() from the D-Bus goroutine when a new request arrives.
type NewRequestMsg struct {
    Request   *approval.Request
    ProcChain []procchain.ProcInfo
}

// RequestResolvedMsg is sent when a request is approved/denied/expired.
type RequestResolvedMsg struct {
    ID         string
    Resolution approval.Resolution
}

// TickMsg fires every second for countdown timer updates.
type TickMsg time.Time
```

Also define an `ApproveResultMsg` for the async approval/deny result:
```go
// ApproveResultMsg carries the result of an async Approve/Deny call.
type ApproveResultMsg struct {
    ID  string
    Err error
}
```

**2. Create `internal/tui/styles.go`:**

Define lipgloss styles for the TUI. Use lipgloss v1 API (no deprecated .Copy()):

- `listPaneStyle` — left pane with border, fixed width proportion
- `detailPaneStyle` — right pane with border, fills remaining width
- `selectedItemStyle` — highlighted item in list (bold, colored background)
- `normalItemStyle` — default list item
- `dimmedStyle` — for resolved/history items
- `secretBadgeStyle` — `[SECRET]` badge in green
- `signBadgeStyle` — `[SIGN]` badge in purple/violet
- `countdownStyle` — countdown timer, yellow when < 60s, red when < 30s
- `headerStyle` — for detail pane headers
- `keyStyle` — for key labels in detail view (bold, dimmed)
- `valueStyle` — for values in detail view

Keep styles simple. Don't over-design — executor can adjust.

**3. Create `internal/tui/list_pane.go`:**

Implement the left pane as a custom list (NOT bubbles/list — it's simpler to build a focused list for this specific layout than to fight bubbles/list's item interface for a split active+history display).

Define `requestItem` struct:
```go
type requestItem struct {
    request   *approval.Request
    procChain []procchain.ProcInfo
    resolved  bool
    resolution approval.Resolution
}
```

Define `listPane` struct with:
- `items []requestItem` — active pending requests
- `history []requestItem` — resolved requests (dimmed, at bottom)
- `cursor int` — selected index in items
- `width, height int`

Methods:
- `SetSize(w, h int)` — updates dimensions
- `AddRequest(req *approval.Request, chain []procchain.ProcInfo)` — appends to items without changing cursor
- `ResolveRequest(id string, resolution approval.Resolution)` — moves from items to history, dims it
- `SelectedItem() *requestItem` — returns item at cursor, or nil
- `View() string` — renders the list with:
  - Type badge: `[SECRET]` or `[SIGN]` per request.Type
  - Short description: first item path for secrets, first 30 chars of commit message for GPG sign
  - Countdown timer: `mm:ss` from ExpiresAt - now
  - Separator line between active and history sections
  - History section header "Recent" with dimmed resolved items showing outcome

Arrow key navigation: up/down changes cursor in items list only (not history).

**4. Create `internal/tui/detail_pane.go`:**

Define `detailPane` struct with:
- `item *requestItem` — currently displayed item (nil = idle state)
- `width, height int`
- Idle state info: daemon uptime, companion user, lock mode, last activity

Methods:
- `SetSize(w, h int)` — updates dimensions
- `SetItem(item *requestItem)` — sets the displayed item
- `SetIdle(uptime time.Duration, companionUser string, lockMode LockMode)` — shows idle state
- `View() string` — renders:
  - If item is nil: idle state with daemon info
  - If item.request.Type == "get_secret": render secret detail (per CONTEXT.md):
    - Secret path
    - Requester: PID, UID, process name
    - Working directory
    - Process chain (up to 5 levels, indented tree format)
  - If item.request.Type == "gpg_sign": render GPG signing detail (per CONTEXT.md):
    - Repo name
    - Commit message (full, not truncated)
    - Author (and committer if different)
    - Changed files with stat summary (e.g. "3 files changed, +47, -12")
    - Key ID
    - Process chain
  - If item.request.Type == "search": render search detail (similar to secret but with search attributes)

Process chain rendering: indent each level, show PID and command name:
```
Process chain:
  git (pid 1234)
  └─ bash (pid 1200)
     └─ tmux: server (pid 900)
        └─ systemd --user (pid 850)
```
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/tui/...</automated>
  </verify>
  <done>
    - Messages, styles, list pane, and detail pane compile cleanly
    - List pane supports type badges, countdown, cursor navigation, and history section
    - Detail pane renders rich context for secret and GPG signing requests
    - Process chain renders in indented tree format
  </done>
</task>

<task type="auto">
  <name>Task 2: Create root TUI model with bubbletea Elm architecture and unit tests</name>
  <files>
    internal/tui/model.go
    internal/tui/model_test.go
  </files>
  <action>
**1. Create `internal/tui/model.go`:**

Root bubbletea Model implementing tea.Model interface. This is the main event loop:

```go
type Config struct {
    LockMode      LockMode
    VTPath        string
    VTFD          uintptr       // file descriptor of opened VT (for lock/unlock)
    CompanionUser string
    StartTime     time.Time
}
```

```go
type Model struct {
    list      listPane
    detail    detailPane
    config    Config
    vtLocked  bool
    width     int
    height    int
    // approveFunc and denyFunc are injected callbacks so the model
    // doesn't need a direct reference to approval.Manager (testability).
    approveFunc func(id string) error
    denyFunc    func(id string) error
}
```

Constructor: `NewModel(cfg Config, approveFn, denyFn func(string) error) Model`

**Init():** Return a `tea.Cmd` that fires TickMsg every second (for countdown updates):
```go
func tickCmd() tea.Cmd {
    return tea.Tick(time.Second, func(t time.Time) tea.Msg {
        return TickMsg(t)
    })
}
```

**Update(msg tea.Msg):** Handle messages:

- `tea.WindowSizeMsg` — store width/height, compute left pane = width/3, right pane = width - width/3. Call list.SetSize and detail.SetSize. Subtract 2 from each dimension for borders (lipgloss border accounting per RESEARCH.md anti-pattern).

- `NewRequestMsg` — call list.AddRequest(msg.Request, msg.ProcChain). If this is the first item, auto-select it in detail pane.

- `RequestResolvedMsg` — call list.ResolveRequest(msg.ID, msg.Resolution). If the resolved item was selected, update detail pane.

- `TickMsg` — trigger re-render (countdown updates). Return tickCmd() to continue ticking.

- `tea.KeyMsg`:
  - `"up"`, `"k"` — move cursor up in list. Update detail pane with new selection. If LockModeAuto: if previous selection had VT locked, unlock; if new selection is pending, lock.
  - `"down"`, `"j"` — move cursor down in list. Same lock logic.
  - `"y"` — if canApprove(): launch async approve command. `canApprove()` checks: selected item is non-nil, not resolved, and (LockModeNone OR vtLocked).
  - `"n"` — if canApprove(): launch async deny command.
  - `"l"` — if LockModeManual: toggle vtLocked. Call LockVT/UnlockVT on config.VTFD.
  - `"esc"` — if vtLocked in Manual or Auto mode: unlock VT. Set vtLocked=false.
  - `"q"`, `"ctrl+c"` — return tea.Quit

- `ApproveResultMsg` — if err is non-nil, could show error in status bar (discretion).

The approve/deny commands should be async (don't block Update):
```go
func approveCmd(approveFn func(string) error, id string) tea.Cmd {
    return func() tea.Msg {
        err := approveFn(id)
        return ApproveResultMsg{ID: id, Err: err}
    }
}
```

**View():** Two-pane layout using lipgloss.JoinHorizontal:
```go
func (m Model) View() string {
    leftW := m.width / 3
    rightW := m.width - leftW
    // ... render with styles and JoinHorizontal(lipgloss.Top, left, right)
}
```

Add a status bar at the bottom showing: lock mode indicator, VT status, help text ("y:approve n:deny l:lock esc:unlock q:quit").

**2. Create `internal/tui/model_test.go`:**

Test the Model using bubbletea's testing approach (call Update directly, check View output):

- `TestModel_NewRequestAppearsInList` — create model, send NewRequestMsg, verify View() contains the request badge and description
- `TestModel_ApproveKey` — send NewRequestMsg, then KeyMsg "y". Verify approveFunc was called with correct ID (use a capturing mock function).
- `TestModel_DenyKey` — same but with "n" and denyFunc.
- `TestModel_CursorNavigation` — send 2 NewRequestMsgs, verify up/down changes selected item in detail pane.
- `TestModel_ResolvedMovesToHistory` — send NewRequestMsg then RequestResolvedMsg, verify item moves to dimmed history section.
- `TestModel_TickContinues` — send TickMsg, verify it returns a command (tickCmd continuation).
- `TestModel_LockModeNone_YWorksWithoutLock` — with LockModeNone, y works even when vtLocked=false.
- `TestModel_LockModeManual_YBlockedWithoutLock` — with LockModeManual and vtLocked=false, y does NOT call approveFunc.

Tests should use `approval.NewManager` to create real requests for realistic test data, or construct *approval.Request directly with test values. Use `func(id string) error` closures to capture calls.

IMPORTANT: Do NOT use `p.Send()` in tests — just call `model.Update(msg)` directly. bubbletea models are testable as pure state machines.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/tui/...</automated>
  </verify>
  <done>
    - Root Model implements tea.Model interface (Init, Update, View)
    - WindowSizeMsg correctly splits width between panes
    - NewRequestMsg adds items to list, RequestResolvedMsg moves to history
    - y/n keystrokes call approve/deny functions when conditions met
    - Lock mode enforcement works (y blocked in ManualLock when unlocked)
    - All 8+ unit tests pass with race detector
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/tui/...
```
All TUI tests pass. View output contains expected content for both request types.
</verification>

<success_criteria>
- bubbletea TUI compiles and renders two-pane layout
- Secret requests show path, PID/UID, process name, working directory, process chain
- GPG signing requests show repo, commit message, author, changed files, stat summary, key ID
- y/n keystrokes trigger approve/deny with lock mode awareness
- New requests appear without stealing focus; resolved requests move to dimmed history
- Unit tests verify all key behaviors via direct model.Update() calls
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-flow/05-02-SUMMARY.md`
</output>

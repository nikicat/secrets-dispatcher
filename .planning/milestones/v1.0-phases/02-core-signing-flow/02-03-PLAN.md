---
phase: 02-core-signing-flow
plan: "03"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - internal/api/handlers.go
  - internal/api/gpgsign.go
autonomous: true
requirements:
  - SIGN-07
  - ERR-02

must_haves:
  truths:
    - "When a gpg_sign request is approved, the daemon calls real gpg with the stored commit object and captures the signature"
    - "GPG exit codes from signing failures propagate through to the Request's GPGExitCode field"
    - "The real gpg signature bytes are stored on the Request so OnEvent (Plan 01) can include them in the WSMessage"
  artifacts:
    - path: "internal/api/gpgsign.go"
      provides: "runRealGPG function and GPGRunner interface"
      contains: "runRealGPG"
    - path: "internal/api/handlers.go"
      provides: "HandleApprove checks gpg_sign type and calls real gpg"
      contains: "ApproveWithSignature"
  key_links:
    - from: "internal/api/handlers.go"
      to: "internal/approval/manager.go"
      via: "GetPending to check type, then ApproveWithSignature or ApproveGPGFailed"
      pattern: "GetPending.*ApproveWithSignature"
    - from: "internal/api/gpgsign.go"
      to: "os/exec gpg subprocess"
      via: "runRealGPG calls real gpg binary"
      pattern: "exec\\.Command"
---

<objective>
Wire real GPG invocation into the daemon's approve flow. When HandleApprove processes a gpg_sign request, it calls real gpg with the commit object, captures the signature and status output, and stores them on the Request for WebSocket delivery.

Purpose: This is the critical daemon-side piece that makes signatures real instead of placeholders. Without it, approved signing requests have no actual PGP signature to return.

Output: HandleApprove calls real gpg for gpg_sign requests. Signature/status/exit code stored on Request. Existing get_secret approve flow unchanged.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-signing-flow/02-RESEARCH.md
@.planning/phases/02-core-signing-flow/02-01-SUMMARY.md

@internal/api/handlers.go
@internal/api/gpgsign.go
@internal/approval/manager.go
@internal/approval/gpgsign.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add runRealGPG function and GPGRunner interface</name>
  <files>
    internal/api/gpgsign.go
  </files>
  <action>
Add to `internal/api/gpgsign.go` (which already has HandleGPGSignRequest):

1. Define a `GPGRunner` interface for testability:
   ```go
   // GPGRunner finds and executes the real gpg binary.
   type GPGRunner interface {
       FindGPG() (string, error)
       RunGPG(gpgPath, keyID string, commitObject []byte) (signature, status []byte, exitCode int, err error)
   }
   ```

2. Implement `defaultGPGRunner` struct implementing GPGRunner:
   - `FindGPG()`: delegates to `gpgsign.FindRealGPG()` from the internal/gpgsign package (Plan 02). Since Plan 02 may not be complete when this plan executes, import the package but the function must exist. If it doesn't compile, implement a local version: scan PATH for "gpg" binary, skip self via os.SameFile. The Plan 02 version is canonical — if both exist, remove the local one.
   - `RunGPG(gpgPath, keyID string, commitObject []byte) (signature, status []byte, exitCode int, err error)`:
     ```go
     func (d *defaultGPGRunner) RunGPG(gpgPath, keyID string, commitObject []byte) ([]byte, []byte, int, error) {
         cmd := exec.Command(gpgPath, "--status-fd=2", "-bsau", keyID)
         cmd.Stdin = bytes.NewReader(commitObject)
         var sigBuf, statusBuf bytes.Buffer
         cmd.Stdout = &sigBuf
         cmd.Stderr = &statusBuf
         err := cmd.Run()
         exitCode := 0
         if err != nil {
             var exitErr *exec.ExitError
             if errors.As(err, &exitErr) {
                 exitCode = exitErr.ExitCode()
             } else {
                 return nil, statusBuf.Bytes(), 1, fmt.Errorf("gpg exec failed: %w", err)
             }
         }
         return sigBuf.Bytes(), statusBuf.Bytes(), exitCode, nil
     }
     ```
   - CRITICAL (Pitfall 6 from RESEARCH.md): Use SEPARATE cmd.Stdout and cmd.Stderr buffers. `--status-fd=2` means gpg writes status to stderr. Mixing them corrupts the signature.

3. Add a `gpgRunner GPGRunner` field to `Handlers` struct. Initialize to `&defaultGPGRunner{}` in both `NewHandlers` and `NewHandlersWithProvider`.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./...</automated>
  </verify>
  <done>runRealGPG function exists and correctly separates stdout (signature) and stderr (status). GPGRunner interface allows test mocking. Handlers struct has gpgRunner field.</done>
</task>

<task type="auto">
  <name>Task 2: Modify HandleApprove to call real GPG for gpg_sign requests</name>
  <files>
    internal/api/handlers.go
  </files>
  <action>
Modify `HandleApprove` in `internal/api/handlers.go`:

Before calling `h.manager.Approve(id)`, look up the request type:

```go
func (h *Handlers) HandleApprove(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        writeError(w, "method not allowed", http.StatusMethodNotAllowed)
        return
    }

    id := extractRequestID(r.URL.Path, "/api/v1/pending/", "/approve")
    if id == "" {
        writeError(w, "invalid request path", http.StatusBadRequest)
        return
    }

    // Check if this is a gpg_sign request that needs real GPG invocation
    req := h.manager.GetPending(id)
    if req == nil {
        writeError(w, "request not found or expired", http.StatusNotFound)
        return
    }

    if req.Type == approval.RequestTypeGPGSign && req.GPGSignInfo != nil {
        // Find real gpg binary
        gpgPath, err := h.gpgRunner.FindGPG()
        if err != nil {
            slog.Error("failed to find real gpg", "error", err)
            // Approve with failure — thin client will see ExitCode != 0
            if apErr := h.manager.ApproveGPGFailed(id, nil, 2); apErr != nil {
                writeError(w, "request not found or expired", http.StatusNotFound)
                return
            }
            writeJSON(w, ActionResponse{Status: "approved"})
            return
        }

        // Run real gpg with the stored commit object
        sig, status, exitCode, err := h.gpgRunner.RunGPG(gpgPath, req.GPGSignInfo.KeyID, []byte(req.GPGSignInfo.CommitObject))
        if err != nil || exitCode != 0 {
            slog.Error("gpg signing failed", "error", err, "exit_code", exitCode)
            if apErr := h.manager.ApproveGPGFailed(id, status, exitCode); apErr != nil {
                writeError(w, "request not found or expired", http.StatusNotFound)
                return
            }
            writeJSON(w, ActionResponse{Status: "approved"})
            return
        }

        // Success — store signature and status, then approve
        if err := h.manager.ApproveWithSignature(id, sig, status); err != nil {
            writeError(w, "request not found or expired", http.StatusNotFound)
            return
        }
        writeJSON(w, ActionResponse{Status: "approved"})
        return
    }

    // Non-gpg_sign requests: existing flow
    if err := h.manager.Approve(id); err != nil {
        if err == approval.ErrNotFound {
            writeError(w, "request not found or expired", http.StatusNotFound)
            return
        }
        writeError(w, err.Error(), http.StatusInternalServerError)
        return
    }

    writeJSON(w, ActionResponse{Status: "approved"})
}
```

Key behaviors:
- SIGN-07: Daemon calls real gpg with `--status-fd=2 -bsau <keyID>`, feeding CommitObject to stdin
- ERR-02: If gpg fails (non-zero exit), `ApproveGPGFailed` stores the exit code; the thin client reads it from the WSMessage.ExitCode field and exits with that code
- The HTTP response is always "approved" (the approve action succeeded from the web UI's perspective). The thin client determines success/failure from the WSMessage.ExitCode field.
- `slog.Error` logs gpg failures for daemon-side debugging
- Non-gpg_sign requests are completely unchanged (existing Approve call)

IMPORTANT: Do NOT add `"log/slog"` import if it's not already in handlers.go. Check first. If not present, add it.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./internal/api/... -timeout 30s</automated>
  </verify>
  <done>HandleApprove calls real gpg for gpg_sign requests, stores signature via ApproveWithSignature or failure via ApproveGPGFailed. Non-gpg_sign approve flow unchanged. All existing tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./... -timeout 60s
```
The approve handler works for both gpg_sign and non-gpg_sign requests. Existing approve tests for get_secret still pass.
</verification>

<success_criteria>
1. HandleApprove detects gpg_sign requests and calls real gpg
2. Signature captured from gpg stdout, status from stderr (separate buffers)
3. GPG exit code captured and stored via ApproveGPGFailed on failure
4. Non-gpg_sign approve flow is identical to before
5. `go build ./...` succeeds, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-signing-flow/02-03-SUMMARY.md`
</output>

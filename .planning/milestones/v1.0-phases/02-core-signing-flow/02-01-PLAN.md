---
phase: 02-core-signing-flow
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/approval/gpgsign.go
  - internal/approval/manager.go
  - internal/api/auth.go
  - internal/api/websocket.go
  - internal/api/server.go
autonomous: true
requirements:
  - SIGN-05
  - SIGN-07
  - SIGN-08

must_haves:
  truths:
    - "Daemon accepts CommitObject in GPG sign requests so it can feed raw commit data to real gpg"
    - "Thin client can authenticate WebSocket connections with Bearer token (not just session cookie)"
    - "Daemon listens on a Unix socket alongside the existing TCP listener"
    - "WSMessage carries GPGStatus and ExitCode fields for thin client to consume"
  artifacts:
    - path: "internal/approval/gpgsign.go"
      provides: "CommitObject field on GPGSignInfo"
      contains: "CommitObject"
    - path: "internal/approval/manager.go"
      provides: "GetPending method and exported signature/status fields on Request"
      contains: "GetPending"
    - path: "internal/api/auth.go"
      provides: "ValidateRequest method checking cookie OR Bearer"
      contains: "ValidateRequest"
    - path: "internal/api/websocket.go"
      provides: "GPGStatus and ExitCode on WSMessage; HandleWS uses ValidateRequest"
      contains: "GPGStatus"
    - path: "internal/api/server.go"
      provides: "Unix socket listener alongside TCP"
      contains: "unix"
  key_links:
    - from: "internal/api/websocket.go"
      to: "internal/api/auth.go"
      via: "HandleWS calls ValidateRequest"
      pattern: "ValidateRequest"
    - from: "internal/api/server.go"
      to: "net.Listen unix"
      via: "second listener on Unix socket"
      pattern: "net\\.Listen.*unix"
---

<objective>
Prepare the daemon-side infrastructure for Phase 2 signing flow: extend data model with CommitObject field, add Manager.GetPending() and exported signature fields, fix WebSocket auth to accept Bearer tokens, add Unix socket listener, and extend WSMessage with GPGStatus/ExitCode fields.

Purpose: Every other Phase 2 plan depends on these daemon-side changes. The thin client needs the Unix socket and Bearer auth to connect. The real GPG invocation needs GetPending and signature storage. The thin client result delivery needs WSMessage extensions.

Output: Modified approval and api packages ready for real GPG wiring (Plan 03) and thin client connection (Plan 04).
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-signing-flow/02-RESEARCH.md

@internal/approval/gpgsign.go
@internal/approval/manager.go
@internal/api/auth.go
@internal/api/websocket.go
@internal/api/server.go
@internal/api/types.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend approval model with CommitObject, GetPending, and signature fields</name>
  <files>
    internal/approval/gpgsign.go
    internal/approval/manager.go
  </files>
  <action>
In `internal/approval/gpgsign.go`:
- Add `CommitObject string json:"commit_object,omitempty"` field to GPGSignInfo struct, after ParentHash. This field carries the raw commit object bytes (UTF-8 text) that the daemon will feed to real gpg's stdin.

In `internal/approval/manager.go`:
- Add exported fields on Request struct for storing real gpg output:
  - `Signature []byte` (rename existing unexported `signature` to exported `Signature`)
  - `GPGStatus []byte json:"-"` (raw [GNUPG:] status lines from gpg stderr)
  - `GPGExitCode int json:"-"` (gpg process exit code; 0 on success)
- Update the comment on Signature to remove "placeholder" / "Phase 1" references.
- Add `GetPending(id string) *Request` method on Manager that returns the pending request by ID (with read lock), or nil if not found:
  ```go
  func (m *Manager) GetPending(id string) *Request {
      m.mu.RLock()
      defer m.mu.RUnlock()
      return m.pending[id]
  }
  ```
- Add `ApproveWithSignature(id string, sig, status []byte) error` method: same as Approve but sets Signature and GPGStatus on the request before closing done.
- Add `ApproveGPGFailed(id string, status []byte, exitCode int) error` method: sets GPGStatus and GPGExitCode, marks result as approved (so the done channel signals), then notifies. The thin client reads ExitCode from the WSMessage and exits with it.

IMPORTANT: Do NOT change the existing Approve() method signature — it's used by get_secret requests. The new methods are additions.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./internal/approval/... -timeout 30s</automated>
  </verify>
  <done>GPGSignInfo has CommitObject field. Manager has GetPending, ApproveWithSignature, ApproveGPGFailed methods. Request has exported Signature, GPGStatus, GPGExitCode fields. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Fix WebSocket auth, add Unix socket listener, extend WSMessage</name>
  <files>
    internal/api/auth.go
    internal/api/websocket.go
    internal/api/server.go
  </files>
  <action>
In `internal/api/auth.go`:
- Add `ValidateRequest(r *http.Request) bool` method on `*Auth` that checks session cookie first (via existing ValidateSession), then falls back to Bearer token from Authorization header (same logic as Middleware). This is the combined validator the RESEARCH.md recommends:
  ```go
  func (a *Auth) ValidateRequest(r *http.Request) bool {
      if a.ValidateSession(r) {
          return true
      }
      parts := strings.SplitN(r.Header.Get("Authorization"), " ", 2)
      if len(parts) == 2 && parts[0] == "Bearer" {
          return subtle.ConstantTimeCompare([]byte(parts[1]), []byte(a.token)) == 1
      }
      return false
  }
  ```
  Note: `strings` and `crypto/subtle` are already imported.

In `internal/api/websocket.go`:
- In `HandleWS`: replace `h.auth.ValidateSession(r)` with `h.auth.ValidateRequest(r)` (Pitfall 2 fix from RESEARCH.md).
- Add `GPGStatus string json:"gpg_status,omitempty"` and `ExitCode int json:"exit_code,omitempty"` fields to WSMessage struct.
- In `OnEvent` for `EventRequestApproved` and gpg_sign type: replace the placeholder signature logic. Instead of `base64.StdEncoding.EncodeToString([]byte("PLACEHOLDER_SIGNATURE"))`, use:
  ```go
  if event.Request.Type == approval.RequestTypeGPGSign {
      msg.Signature = base64.StdEncoding.EncodeToString(event.Request.Signature)
      msg.GPGStatus = string(event.Request.GPGStatus)
      if event.Request.GPGExitCode != 0 {
          msg.ExitCode = event.Request.GPGExitCode
      }
  }
  ```
  This reads the real signature from the Request's exported Signature field (set by ApproveWithSignature in Task 1).

In `internal/api/server.go`:
- Add `UnixSocketPath string` field to Server struct.
- Add `unixListener net.Listener` field to Server struct.
- Modify `newServerWithHandlers` to accept an optional `unixSocketPath string` parameter (add it as a new parameter). If non-empty:
  - Remove any stale socket file: `os.Remove(unixSocketPath)` (ignore error — Pitfall 5)
  - Create directory if needed: `os.MkdirAll(filepath.Dir(unixSocketPath), 0700)`
  - Create Unix listener: `net.Listen("unix", unixSocketPath)`
  - Set socket permissions: `os.Chmod(unixSocketPath, 0600)`
  - Store on Server struct.
- Modify `Start()`: if `s.unixListener != nil`, launch a second goroutine: `go s.httpServer.Serve(s.unixListener)`.
- Modify `Shutdown()`: close Unix listener if non-nil, then remove socket file.
- Update `NewServer` and `NewServerWithProvider` to pass empty string for unixSocketPath (Unix socket path will be wired in main.go in Plan 04).

IMPORTANT: Do NOT modify main.go in this task. The Unix socket path parameter threading to main.go happens in Plan 04.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./internal/api/... -timeout 30s</automated>
  </verify>
  <done>HandleWS accepts Bearer tokens via ValidateRequest. WSMessage has GPGStatus and ExitCode fields. OnEvent sends real signature (from Request.Signature) instead of placeholder. Server supports optional Unix socket listener. All existing tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./... && go test ./... -timeout 60s
```
All packages build, vet clean, all existing tests pass. The placeholder signature in tests may need updating if the test asserts on the exact placeholder value — check 01-03 test expectations.
</verification>

<success_criteria>
1. `go build ./...` succeeds with all model and API changes
2. All existing tests in approval/ and api/ continue to pass
3. GPGSignInfo.CommitObject field exists and serializes correctly
4. Manager.GetPending, ApproveWithSignature, ApproveGPGFailed are callable
5. HandleWS accepts both session cookies and Bearer tokens
6. Server can be constructed with a Unix socket path (even if not wired to main.go yet)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-signing-flow/02-01-SUMMARY.md`
</output>

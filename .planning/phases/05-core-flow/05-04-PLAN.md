---
phase: 05-core-flow
plan: 04
type: tdd
wave: 3
depends_on: ["05-03"]
files_modified:
  - internal/daemon/daemon_test.go
  - internal/daemon/handler_test.go
  - internal/approval/manager.go
  - internal/companion/provision.go
  - internal/companion/templates.go
autonomous: true
requirements: [TEST-02, GPG-02]

must_haves:
  truths:
    - "Integration tests verify RequestSecret and RequestSign D-Bus methods end-to-end with private dbus-daemon"
    - "RequestSecret returns secret path on approval and net.mowaka.Error.Denied on denial"
    - "RequestSign returns GPG signature bytes on approval"
    - "Concurrent D-Bus callers block independently and resolve independently"
    - "Companion gpg-agent is configured with pinentry-tty pointing to VT"
  artifacts:
    - path: "internal/daemon/handler_test.go"
      provides: "Unit tests for RequestSecret and RequestSign with mock resolver and manager"
    - path: "internal/daemon/daemon_test.go"
      provides: "Extended integration tests with private dbus-daemon for new methods"
    - path: "internal/companion/templates.go"
      provides: "GPG_TTY environment in systemd unit template"
      contains: "GPG_TTY"
  key_links:
    - from: "internal/daemon/daemon_test.go"
      to: "D-Bus wire protocol"
      via: "godbus client.Object.Call for RequestSecret/RequestSign"
      pattern: "Call.*RequestSecret|Call.*RequestSign"
    - from: "internal/companion/templates.go"
      to: "gpg-agent pinentry-tty"
      via: "GPG_TTY environment variable in systemd unit"
      pattern: "GPG_TTY"
---

<objective>
Write integration tests that verify the D-Bus handler methods end-to-end, and configure the companion's gpg-agent for pinentry-tty on the VT. Uses TDD: write failing tests first, then ensure Plan 03's implementation passes them.

Purpose: Integration tests prove the D-Bus wire protocol works for real callers. GPG-02 ensures the companion's gpg-agent uses the VT for passphrase prompts.

Output: Extended `daemon_test.go` with RequestSecret/RequestSign integration tests, handler unit tests, and updated systemd unit with GPG_TTY.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-core-flow/05-RESEARCH.md
@.planning/phases/04-foundation/04-02-SUMMARY.md
@.planning/phases/05-core-flow/05-01-SUMMARY.md
@.planning/phases/05-core-flow/05-02-SUMMARY.md
@.planning/phases/05-core-flow/05-03-SUMMARY.md

<interfaces>
<!-- Key interfaces from Plan 03 output. -->

From internal/daemon/dispatcher.go (updated in Plan 03):
```go
type Dispatcher struct {
    version  string
    mgr      *approval.Manager
    program  *tea.Program
    resolver senderResolver
}

func NewDispatcher(version string, mgr *approval.Manager, resolver senderResolver) *Dispatcher
func (d *Dispatcher) SetProgram(p *tea.Program)
func (d *Dispatcher) Ping() (string, *dbus.Error)
func (d *Dispatcher) GetVersion() (string, *dbus.Error)
func (d *Dispatcher) RequestSecret(sender dbus.Sender, path string) (string, *dbus.Error)
func (d *Dispatcher) RequestSign(sender dbus.Sender, repoName, commitMsg, author, committer, keyID string, changedFiles []string, commitObject string) ([]byte, []byte, *dbus.Error)
```

From internal/daemon/daemon.go (updated in Plan 03):
```go
type Config struct {
    BusAddress    string
    Version       string
    VTPath        string
    LockMode      tui.LockMode
    Timeout       time.Duration
    HistoryMax    int
    CompanionUser string
    VTFile        *os.File       // test seam
    Resolver      senderResolver // test seam
}
```

From internal/daemon/handler.go (Plan 03):
```go
// makeDBusError helper
func makeDBusError(name, msg string) *dbus.Error

// senderResolver interface
type senderResolver interface {
    Resolve(sender string) approval.SenderInfo
}

// gpgSigner interface
type gpgSigner interface {
    Sign(commitObject []byte, keyID string) (signature, status []byte, exitCode int, err error)
}
```

From internal/approval/manager.go (may need new method):
```go
func (m *Manager) WaitForResult(id string) (approved bool, err error)
func (m *Manager) CreateSecretRequest(client, path string, senderInfo SenderInfo) (string, error)
```

From internal/daemon/daemon_test.go (Phase 4):
```go
func startDBusDaemonWithPolicy(t *testing.T) string  // returns bus address
func waitForName(t *testing.T, addr, name string)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Manager.CreateSecretRequest and WaitForResult, then write handler unit tests</name>
  <files>
    internal/approval/manager.go
    internal/daemon/handler_test.go
  </files>
  <action>
**1. Add `CreateSecretRequest` and `WaitForResult` to `internal/approval/manager.go`:**

`CreateSecretRequest` follows the same pattern as `CreateGPGSignRequest` — non-blocking, starts timeout goroutine:

```go
// CreateSecretRequest creates a pending get_secret approval request and returns its ID.
// Non-blocking — the caller must use WaitForResult to block until resolution.
func (m *Manager) CreateSecretRequest(client, path string, senderInfo SenderInfo) (string, error) {
    now := time.Now()
    req := &Request{
        ID:        uuid.New().String(),
        Client:    client,
        Items:     []ItemInfo{{Path: path}},
        CreatedAt: now,
        ExpiresAt: now.Add(m.timeout),
        Type:      RequestTypeGetSecret,
        SenderInfo: senderInfo,
        done:      make(chan struct{}),
    }
    m.mu.Lock()
    m.pending[req.ID] = req
    m.mu.Unlock()
    m.notify(Event{Type: EventRequestCreated, Request: req})

    // Timeout goroutine
    go func() {
        select {
        case <-req.done:
        case <-time.After(m.timeout):
            m.mu.Lock()
            _, exists := m.pending[req.ID]
            if exists {
                delete(m.pending, req.ID)
            }
            m.mu.Unlock()
            if exists {
                m.notify(Event{Type: EventRequestExpired, Request: req})
            }
        }
    }()
    return req.ID, nil
}
```

`WaitForResult` blocks until the request's done channel closes, then returns the result:

```go
// WaitForResult blocks until the request with the given ID is resolved.
// Returns (true, nil) if approved, (false, nil) if denied, or (false, ErrTimeout)
// if expired. Returns (false, ErrNotFound) if the ID doesn't exist.
func (m *Manager) WaitForResult(id string) (bool, error) {
    m.mu.RLock()
    req, ok := m.pending[id]
    m.mu.RUnlock()

    if !ok {
        return false, ErrNotFound
    }

    // Block until resolved
    <-req.done
    return req.result, nil
}
```

NOTE: There's a subtle race — the request could be resolved between the RLock/RUnlock and the <-req.done. But since close(req.done) is called before delete(m.pending, id) in Approve/Deny, and after delete in the timeout goroutine... actually looking at the code:
- In Approve: `delete(m.pending, id)` then `close(req.done)` — so if WaitForResult reads pending AFTER delete but BEFORE close, it returns ErrNotFound. This is a race.
- Fix: In CreateSecretRequest/CreateGPGSignRequest, DON'T delete from pending before closing done. Let the caller (WaitForResult) handle cleanup. OR: change the timeout goroutine to close done THEN delete. OR: store the request reference in WaitForResult before the lock is released.

ACTUALLY: looking at the existing code more carefully:
- `Approve()`: `delete(m.pending, id)` then `close(req.done)` — the delete happens WHILE holding m.mu.Lock
- `WaitForResult`: gets req under RLock, releases lock, then blocks on <-req.done
- Race scenario: WaitForResult gets req pointer. Approve fires: deletes from pending, closes done. WaitForResult wakes up. This is FINE because WaitForResult already has the req pointer — it doesn't re-read from pending.
- The only issue: if WaitForResult is called AFTER Approve already completed (done already closed). In that case: RLock, req not in pending (already deleted), returns ErrNotFound. This is a timing issue.
- Fix: make WaitForResult also check if the request is in history as a fallback. OR: have WaitForResult get the pointer before deletion. The simplest fix: In the handlers, call WaitForResult IMMEDIATELY after CreateSecretRequest (in the same goroutine). Since the request was just created, it's guaranteed to be in pending when WaitForResult reads it. The Approve/Deny can only happen after the TUI gets the message, which happens after WaitForResult has already grabbed the pointer.

This ordering is safe. Document it.

**2. Create `internal/daemon/handler_test.go`:**

Unit tests for the handler methods using a mock resolver and real approval.Manager:

```go
// mockResolver implements senderResolver for tests.
type mockResolver struct {
    info approval.SenderInfo
}

func (r *mockResolver) Resolve(sender string) approval.SenderInfo {
    return r.info
}
```

Tests (using direct Dispatcher method calls, NOT D-Bus):

- `TestRequestSecret_Approved`: Create dispatcher with real Manager. Call RequestSecret in goroutine. In another goroutine, poll Manager.List() for the pending request, then call Manager.Approve(id). Verify RequestSecret returns the expected string and no error.

- `TestRequestSecret_Denied`: Same but call Manager.Deny(id). Verify RequestSecret returns a dbus.Error with name "net.mowaka.Error.Denied".

- `TestRequestSecret_Timeout`: Create Manager with 200ms timeout. Call RequestSecret. Don't approve. Verify RequestSecret returns net.mowaka.Error.Timeout after ~200ms.

- `TestRequestSign_Approved`: Create dispatcher with mock gpgSigner that returns fixed signature bytes. Call RequestSign in goroutine. Approve. Verify signature bytes returned.

- `TestRequestSign_Denied`: Call RequestSign, deny. Verify net.mowaka.Error.Denied.

- `TestRequestSecret_NilProgram`: Don't call SetProgram. Verify RequestSecret returns net.mowaka.Error.NotReady.

For tests where program is needed, create a minimal bubbletea program with a noop model:
```go
type noopModel struct{}
func (noopModel) Init() tea.Cmd                           { return nil }
func (noopModel) Update(tea.Msg) (tea.Model, tea.Cmd)     { return noopModel{}, nil }
func (noopModel) View() string                            { return "" }
```
Create the program but DON'T run it. p.Send() is safe to call even if the program isn't running — it just queues the message. Actually, verify this — if p.Run() hasn't been called, p.Send() may panic. If so, use a channel-based stub instead: make SetProgram accept an interface rather than *tea.Program.

SAFER APPROACH: Define a `messageSender` interface:
```go
type messageSender interface {
    Send(msg tea.Msg)
}
```
Have Dispatcher use this instead of `*tea.Program` directly. Tests provide a mock. The real tea.Program satisfies this interface. This avoids needing to create a real bubbletea program in unit tests.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/daemon/... ./internal/approval/...</automated>
  </verify>
  <done>
    - Manager.CreateSecretRequest creates non-blocking get_secret requests with timeout
    - Manager.WaitForResult blocks until resolution and returns (approved, error)
    - Handler unit tests verify RequestSecret approve/deny/timeout paths
    - Handler unit tests verify RequestSign approve/deny paths
    - NilProgram test verifies graceful error when TUI not initialized
  </done>
</task>

<task type="auto">
  <name>Task 2: D-Bus integration tests and GPG-02 pinentry-tty configuration</name>
  <files>
    internal/daemon/daemon_test.go
    internal/companion/templates.go
    internal/companion/provision.go
  </files>
  <action>
**1. Extend `internal/daemon/daemon_test.go` with integration tests:**

These tests use the existing `startDBusDaemonWithPolicy()` helper and real D-Bus wire protocol. The daemon runs in headless mode (no VT) so the TUI doesn't start — but the D-Bus methods are still callable.

Add a helper to start the daemon with approval.Manager accessible:
```go
// startDaemonForTest starts a headless daemon on a private bus and returns
// the bus address, a function to approve/deny requests, and a cleanup function.
func startDaemonForTest(t *testing.T, timeout time.Duration) (addr string, mgr *approval.Manager, cancel context.CancelFunc) {
    t.Helper()
    addr = startDBusDaemonWithPolicy(t)
    mgr = approval.NewManager(timeout, 100)

    ctx, cancel := context.WithCancel(context.Background())

    // We need to pass the manager to Run(). The current Config doesn't expose mgr.
    // OPTION: Add Manager to Config as a test seam (like Resolver).
    // Add: ApprovalManager *approval.Manager to Config. If non-nil, use it; otherwise create new.
    ...
}
```

ISSUE: The current daemon.Run() creates its own approval.Manager internally. For integration tests, we need to control the Manager (to call Approve/Deny). Two approaches:
1. Add `ApprovalManager *approval.Manager` to Config as a test seam
2. Use D-Bus to make the method call, then approve from the same test by calling another D-Bus method

Option 1 is cleaner. Add the test seam to Config.

**Integration tests:**

- `TestDaemon_RequestSecret_ApproveViaDirect`: Start daemon. Client calls `RequestSecret("github/token")` via D-Bus in a goroutine. Test goroutine polls `mgr.List()`, finds the request, calls `mgr.Approve(id)`. Client's D-Bus call returns the approved secret. Verify no error.

- `TestDaemon_RequestSecret_Deny`: Same but call `mgr.Deny(id)`. Verify client gets `net.mowaka.Error.Denied`.

- `TestDaemon_RequestSecret_Timeout`: Use 500ms timeout. Don't approve. Verify client gets `net.mowaka.Error.Timeout` within ~1s.

- `TestDaemon_ConcurrentRequests`: Two goroutines call RequestSecret simultaneously with different paths. Approve one, deny the other. Verify each gets the correct result independently. This verifies godbus concurrent dispatch.

- `TestDaemon_RequestSign_Approve`: Client calls RequestSign with GPG signing parameters. Approve. Verify returns signature bytes (mock GPG signer).

For calling the D-Bus methods from the test client:
```go
client, err := dbus.Connect(addr)
obj := client.Object(BusName, ObjectPath)

var secret string
err := obj.Call(Interface+".RequestSecret", 0, "/github/token").Store(&secret)
```

NOTE: The D-Bus method signatures must match exactly. godbus marshals/unmarshals by positional arguments. If RequestSecret takes `(sender dbus.Sender, path string)`, the caller only sends `path` — `sender` is injected by godbus from the connection's unique name.

**2. Update `internal/companion/templates.go` for GPG-02:**

Add `GPG_TTY` and pinentry configuration to the systemd unit template. Per RESEARCH.md Pattern 6:

Update `systemdUnitTemplate`:
```go
const systemdUnitTemplate = `[Unit]
Description=Secrets Dispatcher Companion Daemon
Documentation=https://github.com/nikicat/secrets-dispatcher
After=dbus.service
Requires=dbus.service

[Service]
Type=notify
ExecStart=/usr/local/bin/secrets-dispatcher daemon
Environment=HOME={{.CompanionHome}}
Environment=XDG_RUNTIME_DIR=/run/user/{{.CompanionUID}}
Environment=GPG_TTY={{.VTPath}}
Environment=GNUPGHOME={{.CompanionHome}}/.gnupg
Restart=on-failure
RestartSec=5

[Install]
WantedBy=default.target
`
```

Add `VTPath` field to the template vars struct in `provision.go`:
```go
type templateVars struct {
    CompanionHome string
    CompanionUID  string
    VTPath        string  // default: "/dev/tty8"
}
```

Default VTPath to "/dev/tty8" if not specified.

**3. Add provisioning step for gpg-agent pinentry config:**

In `provision.go`, add a step after directory skeleton to write gpg-agent.conf:

```go
// 4b. Write gpg-agent.conf with pinentry-tty pointing to VT.
if err := writeGPGAgentConf(homeDir, uid, gid, vtPath); err != nil {
    return fmt.Errorf("write gpg-agent.conf: %w", err)
}
```

Implement `writeGPGAgentConf`:
```go
func writeGPGAgentConf(homeDir string, uid, gid int, vtPath string) error {
    if vtPath == "" {
        vtPath = "/dev/tty8"
    }
    content := fmt.Sprintf("pinentry-program /usr/bin/pinentry-tty\nkeep-tty\n")
    confPath := filepath.Join(homeDir, ".gnupg", "gpg-agent.conf")
    slog.Info("writing gpg-agent.conf", "path", confPath)
    if err := writeFileFunc(confPath, []byte(content), 0600); err != nil {
        return err
    }
    return chownFunc(confPath, uid, gid)
}
```

Note: `keep-tty` tells gpg-agent to always use the configured TTY even if another TTY triggered the request. Combined with `GPG_TTY=/dev/tty8` in the systemd unit, this ensures pinentry always appears on the VT.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 -timeout=60s ./internal/daemon/... ./internal/companion/...</automated>
  </verify>
  <done>
    - Integration tests verify RequestSecret approve/deny/timeout over real D-Bus wire protocol
    - Concurrent request test proves independent blocking resolution
    - RequestSign integration test verifies GPG signing flow
    - systemd unit template includes GPG_TTY pointing to VT
    - gpg-agent.conf written with pinentry-tty and keep-tty
    - All tests pass including Phase 4 regression tests
  </done>
</task>

</tasks>

<verification>
```bash
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 -timeout=60s ./internal/daemon/... ./internal/approval/... ./internal/companion/...
```
All tests pass. Integration tests confirm D-Bus wire protocol works for new methods.
</verification>

<success_criteria>
- Handler unit tests cover approve/deny/timeout for both RequestSecret and RequestSign
- Integration tests run with private dbus-daemon (no root required)
- Concurrent D-Bus callers resolve independently
- GPG-02: gpg-agent.conf written with pinentry-tty, systemd unit has GPG_TTY
- Phase 4 regression tests still pass
- All tests pass with race detector and 60s timeout
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-flow/05-04-SUMMARY.md`
</output>

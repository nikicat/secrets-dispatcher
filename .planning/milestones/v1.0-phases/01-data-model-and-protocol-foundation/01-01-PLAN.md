---
phase: 01-data-model-and-protocol-foundation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/approval/gpgsign.go
  - internal/approval/manager.go
autonomous: true
requirements:
  - SIGN-06
  - SIGN-09
  - ERR-03

must_haves:
  truths:
    - "A gpg_sign approval request can be created via CreateGPGSignRequest and immediately returns a request ID"
    - "The GPGSignInfo struct carries repo name, commit message, author, committer, key ID, fingerprint, changed files, and parent hash"
    - "A gpg_sign request expires via the existing timeout mechanism (EventRequestExpired fires after manager timeout)"
    - "A gpg_sign request can be approved or denied via the existing Approve/Deny methods"
  artifacts:
    - path: "internal/approval/gpgsign.go"
      provides: "RequestTypeGPGSign constant, GPGSignInfo struct, CreateGPGSignRequest method"
      contains: "RequestTypeGPGSign"
    - path: "internal/approval/manager.go"
      provides: "Request.GPGSignInfo field, Request.signature field"
      contains: "GPGSignInfo"
  key_links:
    - from: "internal/approval/gpgsign.go"
      to: "internal/approval/manager.go"
      via: "Manager receiver method CreateGPGSignRequest"
      pattern: "func \\(m \\*Manager\\) CreateGPGSignRequest"
    - from: "internal/approval/manager.go"
      to: "approval event pipeline"
      via: "m.notify(Event{Type: EventRequestCreated}) in CreateGPGSignRequest"
      pattern: "EventRequestCreated"
---

<objective>
Define the gpg_sign data model in the approval layer and add a non-blocking CreateGPGSignRequest method to Manager.

Purpose: All other Phase 1 components (API handler, WebSocket events, serialization) depend on these types existing. This is the foundation.
Output: internal/approval/gpgsign.go (new), internal/approval/manager.go (extended with two new fields and one new method)
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-data-model-and-protocol-foundation/01-CONTEXT.md
@.planning/phases/01-data-model-and-protocol-foundation/01-RESEARCH.md
@internal/approval/manager.go
@internal/approval/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GPGSignInfo struct, RequestTypeGPGSign constant, and signature field to Request</name>
  <files>
    internal/approval/gpgsign.go
    internal/approval/manager.go
  </files>
  <action>
Create `internal/approval/gpgsign.go` in package `approval`:

1. Add constant: `RequestTypeGPGSign RequestType = "gpg_sign"` (alongside existing RequestTypeGetSecret and RequestTypeSearch in manager.go — do NOT re-declare RequestType, just add the constant in the new file)

2. Add struct:
```go
// GPGSignInfo carries the commit context fields for a signing approval request.
// All fields are supplied by the thin client (Phase 2); in Phase 1 they come from
// the POST body sent by tests or manual API calls.
type GPGSignInfo struct {
    RepoName     string   `json:"repo_name"`
    CommitMsg    string   `json:"commit_msg"`
    Author       string   `json:"author"`
    Committer    string   `json:"committer"`
    KeyID        string   `json:"key_id"`
    Fingerprint  string   `json:"fingerprint,omitempty"`
    ChangedFiles []string `json:"changed_files"`
    ParentHash   string   `json:"parent_hash,omitempty"`
}
```

In `internal/approval/manager.go`, extend the `Request` struct with two new fields (add after existing fields, before the closing brace):
- `GPGSignInfo *GPGSignInfo \`json:"gpg_sign_info,omitempty"\`` — pointer, nil for non-gpg_sign requests
- `signature []byte` — unexported; set to placeholder bytes on approval for gpg_sign requests in Phase 1; Phase 2 replaces with real gpg output

Do NOT change the `Approve(id string) error` or `Deny(id string) error` signatures. The `signature` field is only set by the handler after `EventRequestApproved` fires in Phase 1 (Phase 2 will wire real gpg output here).
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/approval/...</automated>
  </verify>
  <done>go build ./internal/approval/... exits 0; Request struct has GPGSignInfo and signature fields; RequestTypeGPGSign constant exists in package approval</done>
</task>

<task type="auto">
  <name>Task 2: Add CreateGPGSignRequest non-blocking manager method</name>
  <files>
    internal/approval/gpgsign.go
  </files>
  <action>
Add `CreateGPGSignRequest` as a method on `*Manager` in `internal/approval/gpgsign.go`:

```go
// CreateGPGSignRequest creates a pending gpg_sign approval request and returns its ID.
// It does NOT block — the result is delivered to the caller via the WebSocket observer
// pipeline (EventRequestApproved / EventRequestDenied / EventRequestExpired).
// Uses context.Background() for the timeout goroutine so a dropped HTTP connection does
// not cancel a request the user is actively reviewing in the web UI.
func (m *Manager) CreateGPGSignRequest(client string, info *GPGSignInfo) (string, error) {
    if info == nil {
        return "", errors.New("gpg sign info is required")
    }
    now := time.Now()
    req := &Request{
        ID:          uuid.New().String(),
        Client:      client,
        CreatedAt:   now,
        ExpiresAt:   now.Add(m.timeout),
        Type:        RequestTypeGPGSign,
        GPGSignInfo: info,
        done:        make(chan struct{}),
    }
    m.mu.Lock()
    m.pending[req.ID] = req
    m.mu.Unlock()
    m.notify(Event{Type: EventRequestCreated, Request: req})

    // Timeout goroutine — mirrors the timer.C branch in RequireApproval.
    // ERR-03: gpg_sign requests expire via the existing timeout mechanism.
    go func() {
        select {
        case <-req.done:
            // resolved by Approve or Deny — no action needed
        case <-time.After(m.timeout):
            m.mu.Lock()
            delete(m.pending, req.ID)
            m.mu.Unlock()
            m.notify(Event{Type: EventRequestExpired, Request: req})
        }
    }()
    return req.ID, nil
}
```

Imports needed in gpgsign.go: `"errors"`, `"time"`, `"github.com/google/uuid"`. Confirm these are available in go.mod (they already are per RESEARCH.md).

Do NOT use the HTTP request context for the goroutine — use the fire-and-forget pattern above so a dropped connection does not cancel a pending approval.
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/approval/... && go vet ./internal/approval/...</automated>
  </verify>
  <done>go build and go vet both exit 0; CreateGPGSignRequest method exists on *Manager; method is non-blocking (returns immediately after registering request)</done>
</task>

</tasks>

<verification>
cd /home/nb/src/secrets-dispatcher && go build ./... && go vet ./...

Both must exit 0. No new imports added to go.mod (all dependencies already exist per RESEARCH.md).
</verification>

<success_criteria>
1. `internal/approval/gpgsign.go` exists with: RequestTypeGPGSign constant, GPGSignInfo struct (8 fields), CreateGPGSignRequest method on *Manager
2. `internal/approval/manager.go` has GPGSignInfo *GPGSignInfo and signature []byte fields on Request struct
3. go build ./... exits 0
4. go vet ./... exits 0
5. No new external dependencies added to go.mod
</success_criteria>

<output>
After completion, create `.planning/phases/01-data-model-and-protocol-foundation/01-01-SUMMARY.md`
</output>

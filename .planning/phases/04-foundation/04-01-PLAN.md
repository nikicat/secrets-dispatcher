---
phase: 04-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/companion/provision.go
  - internal/companion/check.go
  - internal/companion/sysfuncs.go
  - internal/companion/templates.go
  - internal/companion/provision_test.go
  - internal/companion/check_test.go
  - main.go
autonomous: true
requirements:
  - COMP-01
  - COMP-02
  - COMP-05
  - DBUS-02
  - PROV-01
  - PROV-02
  - PROV-03
  - PROV-04
  - PROV-05
  - TEST-04

must_haves:
  truths:
    - "Running `secrets-dispatcher provision --user nb` (as root) creates companion user secrets-nb with 0700 home at /var/lib/secret-companion/nb"
    - "Running `secrets-dispatcher provision --user nb` a second time succeeds without error (idempotent)"
    - "Running `secrets-dispatcher provision --check --user nb` prints pass/fail checklist for each component with actionable fix hints"
    - "Provisioning creates D-Bus policy file, systemd user unit, PAM hook config, and gopass/GPG directory skeleton"
    - "Running `secrets-dispatcher provision` without root exits with clear error message"
    - "Unit tests for provisioning and check run with `go test ./internal/companion/...` without root, real users, or real systemctl"
  artifacts:
    - path: "internal/companion/provision.go"
      provides: "Provision() orchestrator and individual provisioning steps"
      exports: ["Provision", "Config"]
    - path: "internal/companion/check.go"
      provides: "Check() deployment validator with pass/fail per component"
      exports: ["Check", "CheckResult"]
    - path: "internal/companion/sysfuncs.go"
      provides: "Injectable system call function variables for testability"
      exports: ["UserAddFunc", "LoginctlFunc"]
    - path: "internal/companion/templates.go"
      provides: "Embedded D-Bus policy, systemd unit, and PAM config templates"
      contains: "go:embed"
    - path: "internal/companion/provision_test.go"
      provides: "Unit tests for Provision with mocked system calls"
      min_lines: 80
    - path: "internal/companion/check_test.go"
      provides: "Unit tests for Check with mocked lookups"
      min_lines: 40
    - path: "main.go"
      provides: "provision subcommand routing"
      contains: "case \"provision\""
  key_links:
    - from: "main.go"
      to: "internal/companion/provision.go"
      via: "switch case calling companion.Provision() and companion.Check()"
      pattern: "companion\\.Provision|companion\\.Check"
    - from: "internal/companion/provision.go"
      to: "internal/companion/sysfuncs.go"
      via: "calling injectable function vars for useradd, loginctl, etc."
      pattern: "userAddFunc|loginctlFunc|mkdirAllFunc"
    - from: "internal/companion/provision_test.go"
      to: "internal/companion/sysfuncs.go"
      via: "swapping function vars with test fakes"
      pattern: "userAddFunc\\s*="
---

<objective>
Create the `secrets-dispatcher provision` subcommand that provisions a companion user with all deployment artifacts (user account, home directory, D-Bus policy file, systemd unit, PAM hook, gopass/GPG directory skeleton) and a `--check` validator that reports pass/fail per component.

Purpose: This is the bootstrap tool for the entire v2.0 privilege separation model. Without provisioning, nothing else in Phases 5-8 can run. The provisioning tool must be idempotent, non-interactive, and require root.

Output: `internal/companion/` package with Provision/Check logic, unit tests with mocked syscalls, and "provision" subcommand in main.go.
</objective>

<execution_context>
@/home/nb/.claude-personal/get-shit-done/workflows/execute-plan.md
@/home/nb/.claude-personal/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-foundation/04-CONTEXT.md
@.planning/phases/04-foundation/04-RESEARCH.md

<interfaces>
<!-- Key patterns and contracts the executor needs. Extracted from codebase. -->

From main.go (CLI dispatch pattern — extend this switch):
```go
switch os.Args[1] {
case "serve":
    runServe(os.Args[2:])
// ... existing cases ...
case "service":
    runService(os.Args[2:])
case "gpg-sign":
    runGPGSign(os.Args[2:])
// ADD: case "provision":
//     runProvision(os.Args[2:])
}
```

From internal/service/install.go (injectable function var pattern to follow):
```go
// systemctlFunc is the function used to run systemctl commands.
// Replaced in tests to avoid requiring a real systemd.
var systemctlFunc = systemctlExec

func systemctlExec(args ...string) error {
    fullArgs := append([]string{"--user"}, args...)
    cmd := exec.Command("systemctl", fullArgs...)
    // ...
}
```

From internal/service/install_test.go (test swap pattern to follow):
```go
origSystemctl := systemctlFunc
var calls []string
systemctlFunc = func(args ...string) error {
    calls = append(calls, strings.Join(args, " "))
    return nil
}
t.Cleanup(func() { systemctlFunc = origSystemctl })
```

From main.go printUsage() (add provision to help text):
```go
func printUsage() {
    fmt.Fprintf(os.Stderr, `Usage: %s <command> [options]
Commands:
  serve         Start the proxy server and API
  // ... existing ...
  // ADD: provision    Provision companion user and deployment artifacts
`)
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create internal/companion package with provisioning and check logic</name>
  <files>
    internal/companion/provision.go
    internal/companion/check.go
    internal/companion/sysfuncs.go
    internal/companion/templates.go
  </files>
  <action>
Create the `internal/companion/` package with four files:

**sysfuncs.go** — Injectable system call function variables (same pattern as `internal/service/install.go` systemctlFunc):
- `userAddFunc` — calls `useradd --no-create-home --shell /usr/sbin/nologin --home-dir {homeDir} {username}` (NO `--system` flag — companion needs regular UID range for systemd --user to work, see Pitfall 2 in RESEARCH.md)
- `loginctlFunc` — calls `loginctl enable-linger {username}`
- `userLookupFunc` — wraps `os/user.Lookup()` (injectable for tests)
- `mkdirAllFunc`, `chownFunc`, `chmodFunc`, `writeFileFunc` — wraps os functions
- All default to real implementations; tests swap them out

**templates.go** — Embedded templates using `go:embed` or string constants:
- D-Bus policy file template (`net.mowaka.SecretsDispatcher1.conf`) — use the VERIFIED template from RESEARCH.md Pattern 5. Template variables: `{{.CompanionUser}}` and `{{.DesktopUser}}`. Install location: `/usr/share/dbus-1/system.d/net.mowaka.SecretsDispatcher1.conf`
- systemd user unit file template for the companion daemon — Type=notify (for sd-notify), ExecStart pointing to `secrets-dispatcher daemon`, with Environment=HOME and XDG_RUNTIME_DIR. Install location: companion user's `~/.config/systemd/user/secrets-dispatcher-daemon.service`
- PAM config snippet — `session optional pam_exec.so quiet /usr/bin/systemctl start --no-block secrets-dispatcher-companion@%u.service`. Install location: `/etc/pam.d/secrets-dispatcher` (for PROV-02, actual PAM testing is VM E2E)
- Use `text/template` for rendering, not `fmt.Sprintf`

**provision.go** — Main provisioning orchestrator:
- `Config` struct with fields: `DesktopUser string`, `CompanionName string` (default "secrets-{DesktopUser}"), `HomeBase string` (default "/var/lib/secret-companion")
- `Provision(cfg Config) error` — the main entry point. Steps in order:
  1. Validate: must be root (`os.Geteuid() == 0`), DesktopUser must not be empty
  2. If DesktopUser empty, read from `SUDO_USER` env var. If still empty, return error with message "specify --user flag or run via sudo" (Pitfall 4)
  3. Derive companion username: `cfg.CompanionName` or `"secrets-" + cfg.DesktopUser`
  4. Derive home dir: `filepath.Join(cfg.HomeBase, cfg.DesktopUser)`
  5. Create companion user (idempotent: check `userLookupFunc` first, skip if exists)
  6. Create home directory with 0700, chown to companion user
  7. Create gopass/GPG directory skeleton: `$HOME/.config/gopass/`, `$HOME/.gnupg/` — owned by companion, 0700 (PROV-03 Phase 4 scope = dirs only, NOT gopass init)
  8. Write D-Bus policy file to `/usr/share/dbus-1/system.d/net.mowaka.SecretsDispatcher1.conf` (rendered template)
  9. Write systemd user unit file to companion's `~/.config/systemd/user/secrets-dispatcher-daemon.service` (rendered template)
  10. Write PAM config to `/etc/pam.d/secrets-dispatcher` (rendered template)
  11. Enable linger: `loginctlFunc("enable-linger", companionUsername)`
  12. Log each step with slog.Info
- Each step is idempotent (PROV-05): directories use MkdirAll, user creation checks existence first, file writes overwrite, linger is already idempotent
- Return first error with context (fmt.Errorf wrapping)

**check.go** — Deployment validator:
- `CheckResult` struct: `Name string`, `Pass bool`, `Message string` (fix hint on failure)
- `Check(cfg Config) []CheckResult` — runs all checks, returns slice. Each check is independent:
  1. Companion user exists (os/user.Lookup)
  2. Home directory exists and is 0700
  3. Home directory owned by companion user
  4. gopass config dir exists
  5. GPG home dir exists
  6. D-Bus policy file exists at expected path
  7. systemd user unit file exists
  8. PAM config exists
  9. Linger enabled (check `/var/lib/systemd/linger/{username}` file exists)
- Check does NOT require root — all checks are read-only stat/lookup operations
- Output format: each result printed as `[PASS]` or `[FAIL]` with fix hint

IMPORTANT constraints from CONTEXT.md:
- Non-interactive, no prompts
- Requires root for provision, fails immediately if not root
- Detect desktop user from SUDO_USER env var
- `--companion-name` flag allows non-default companion usernames
- Shell: /usr/sbin/nologin
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go build ./internal/companion/</automated>
  </verify>
  <done>
    - internal/companion/ package compiles with provision.go, check.go, sysfuncs.go, templates.go
    - Provision() creates user, dirs, D-Bus policy, systemd unit, PAM config, enables linger
    - Check() validates all components with pass/fail + fix hints
    - All system calls go through injectable function variables
    - Idempotent: repeated Provision() calls succeed without error
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests and wire provision subcommand into main.go</name>
  <files>
    internal/companion/provision_test.go
    internal/companion/check_test.go
    main.go
  </files>
  <action>
**provision_test.go** — Unit tests with mocked system calls (follow `internal/service/install_test.go` pattern):

Test cases for Provision():
1. `TestProvision_CreatesUser` — mock userLookupFunc to return "not found", mock userAddFunc to record call. Verify useradd called with correct username, home dir, nologin shell. Verify NO `--system` flag.
2. `TestProvision_SkipsExistingUser` — mock userLookupFunc to return success. Verify userAddFunc NOT called (idempotent).
3. `TestProvision_CreatesDirectories` — mock all syscalls. Verify mkdirAllFunc called for: parent dir (0755), home dir (0700), gopass dir, gnupg dir. Verify chownFunc called with correct UID/GID.
4. `TestProvision_WritesDBusPolicy` — mock writeFileFunc, capture written content. Verify it contains companion username and desktop username in correct policy positions.
5. `TestProvision_WritesSystemdUnit` — mock writeFileFunc, capture written content. Verify ExecStart contains "secrets-dispatcher daemon", Type=notify.
6. `TestProvision_WritesPAMConfig` — mock writeFileFunc, capture written content. Verify pam_exec.so reference.
7. `TestProvision_EnablesLinger` — mock loginctlFunc, verify called with "enable-linger" and companion username.
8. `TestProvision_RequiresRoot` — set euid check to fail (injectable or skip if not easily testable). Verify returns error.
9. `TestProvision_DetectsSUDO_USER` — set SUDO_USER env var, call with empty DesktopUser. Verify uses SUDO_USER.
10. `TestProvision_FailsWithoutUser` — empty DesktopUser, no SUDO_USER. Verify returns clear error.
11. `TestProvision_Idempotent` — run Provision twice with same mocks. Both should succeed.

For each test: swap the relevant function vars, use t.Cleanup to restore, use t.TempDir() for any temp paths. Use the same save-and-restore pattern from install_test.go.

For tests that verify file content (D-Bus policy, systemd unit): use a real temp dir and real os.WriteFile (don't mock writeFileFunc for those tests), then read back and assert content. This avoids the mock capturing complexity while still not requiring root.

For the root check: make the euid check injectable too (add `geteuidFunc` to sysfuncs.go that defaults to `os.Geteuid`).

**check_test.go** — Unit tests for Check():
1. `TestCheck_AllPass` — set up a temp dir with all expected files/dirs. Mock userLookupFunc. Verify all results are Pass.
2. `TestCheck_MissingUser` — mock userLookupFunc to return error. Verify first check fails with helpful message.
3. `TestCheck_MissingFiles` — set up partial structure. Verify correct checks fail.
4. `TestCheck_LingerMissing` — verify linger check fails when file absent.

**main.go changes:**
1. Add `case "provision":` to the switch in main(), calling `runProvision(os.Args[2:])`
2. Add `runProvision(args []string)` function:
   - Parse flags: `--user` (string, desktop username), `--companion-name` (string, optional override), `--check` (bool, run check instead of provision), `--home-base` (string, default "/var/lib/secret-companion")
   - If `--check`: call `companion.Check(cfg)`, print results, exit 0 if all pass, exit 1 if any fail
   - Otherwise: call `companion.Provision(cfg)`, exit 0 on success, exit 1 with error on failure
3. Add "provision" to printUsage() help text:
   ```
   provision     Provision companion user and deployment artifacts
   ```
4. Add import for `"github.com/nikicat/secrets-dispatcher/internal/companion"`
  </action>
  <verify>
    <automated>cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./internal/companion/...</automated>
  </verify>
  <done>
    - All unit tests pass with `go test -race ./internal/companion/...`
    - Tests run without root, real users, or real systemctl (TEST-04)
    - `secrets-dispatcher provision` subcommand is wired and compiles
    - `go build .` succeeds with the new provision case
  </done>
</task>

</tasks>

<verification>
```bash
# All companion tests pass
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 -v ./internal/companion/...

# Full project still compiles
cd /home/nb/src/secrets-dispatcher && go build .

# Existing tests still pass (no regression)
cd /home/nb/src/secrets-dispatcher && go test -race -count=1 ./...
```
</verification>

<success_criteria>
- `internal/companion/` package exists with provision, check, sysfuncs, templates files
- `Provision()` creates companion user with correct home dir, permissions, D-Bus policy, systemd unit, PAM hook, gopass/GPG dirs, linger
- `Check()` validates all deployment components with pass/fail + fix hints
- All provisioning system calls go through injectable function variables
- Unit tests verify all provisioning steps without root
- `secrets-dispatcher provision [--check] --user {name}` is a working subcommand
- `go test -race ./internal/companion/...` passes
- `go test -race ./...` passes (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/04-foundation/04-01-SUMMARY.md`
</output>
